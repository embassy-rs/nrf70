/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const RPU_ADDR_SPI_START: u32 = 0x0;
pub const RPU_ADDR_GRAM_START: u32 = 0xb7000000;
pub const RPU_ADDR_GRAM_END: u32 = 0xb70101ff;
pub const RPU_ADDR_SBUS_START: u32 = 0xa4000000;
pub const RPU_ADDR_SBUS_END: u32 = 0xa4007fff;
pub const RPU_ADDR_PBUS_START: u32 = 0xa5000000;
pub const RPU_ADDR_PBUS_END: u32 = 0xa503ffff;
pub const RPU_ADDR_BEV_START: u32 = 0xbfc00000;
pub const RPU_ADDR_BEV_END: u32 = 0xbfcfffff;
pub const RPU_ADDR_PKTRAM_START: u32 = 0xb0000000;
pub const RPU_ADDR_PKTRAM_END: u32 = 0xb0030fff;
pub const RPU_ADDR_LMAC_CORE_RET_START: u32 = 0x80040000;
pub const RPU_ADDR_UMAC_CORE_RET_START: u32 = 0x80080000;
pub const RPU_ADDR_MASK_BASE: u32 = 0xff000000;
pub const RPU_ADDR_MASK_OFFSET: u32 = 0xffffff;
pub const RPU_ADDR_MASK_BEV_OFFSET: u32 = 0xfffff;
pub const RPU_REG_INT_FROM_RPU_CTRL: u32 = 0xa4000400;
pub const RPU_REG_BIT_INT_FROM_RPU_CTRL: u32 = 0x11;
pub const RPU_REG_INT_TO_MCU_CTRL: u32 = 0xa4000480;
pub const RPU_REG_INT_FROM_MCU_ACK: u32 = 0xa4000488;
pub const RPU_REG_BIT_INT_FROM_MCU_ACK: u32 = 0x1f;
pub const RPU_REG_INT_FROM_MCU_CTRL: u32 = 0xa4000494;
pub const RPU_REG_BIT_INT_FROM_MCU_CTRL: u32 = 0x1f;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_0: u32 = 0xa4002c2c;
pub const RPU_REG_UCC_SLEEP_CTRL_DATA_1: u32 = 0xa4002c30;
pub const RPU_REG_MIPS_MCU_CONTROL: u32 = 0xa4000000;
pub const RPU_REG_BIT_MIPS_MCU_LATCH_SOFT_RESET: u32 = 0x1;
pub const RPU_REG_MIPS_MCU2_CONTROL: u32 = 0xa4000100;
pub const RPU_REG_MIPS_MCU_UCCP_INT_STATUS: u32 = 0xa4000004;
pub const RPU_REG_BIT_MIPS_UCCP_INT_STATUS: u32 = 0x0;
pub const RPU_REG_BIT_MIPS_WATCHDOG_INT_STATUS: u32 = 0x1;
pub const RPU_REG_MIPS_MCU_TIMER_CONTROL: u32 = 0xa4000048;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_CTRL: u32 = 0xa4000030;
pub const RPU_REG_MIPS_MCU_SYS_CORE_MEM_WDATA: u32 = 0xa4000034;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_0: u32 = 0xa4000050;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_1: u32 = 0xa4000054;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_2: u32 = 0xa4000058;
pub const RPU_REG_MIPS_MCU_BOOT_EXCP_INSTR_3: u32 = 0xa400005c;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_CTRL: u32 = 0xa4000130;
pub const RPU_REG_MIPS_MCU2_SYS_CORE_MEM_WDATA: u32 = 0xa4000134;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_0: u32 = 0xa4000150;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_1: u32 = 0xa4000154;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_2: u32 = 0xa4000158;
pub const RPU_REG_MIPS_MCU2_BOOT_EXCP_INSTR_3: u32 = 0xa400015c;
pub const RPU_REG_MCP_SYS_CSTRCTRL: u32 = 0xa4001200;
pub const RPU_REG_MCP_SYS_CSTRDAT32: u32 = 0xa4001218;
pub const RPU_REG_MCP2_SYS_CSTRCTRL: u32 = 0xa4003200;
pub const RPU_REG_MCP2_SYS_CSTRDAT32: u32 = 0xa4003218;
pub const RPU_REG_MCP3_SYS_CSTRCTRL: u32 = 0xa4004200;
pub const RPU_REG_MCP3_SYS_CSTRDAT32: u32 = 0xa4004218;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_00: u32 = 0xa401c200;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_01: u32 = 0xa401c204;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_02: u32 = 0xa401c208;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_04: u32 = 0xa401c210;
pub const RPU_REG_RFCTL_UCC_RF_CTRL_CONFIG_16: u32 = 0xa401c260;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_0: u32 = 0xa401c300;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_1: u32 = 0xa401c304;
pub const RPU_REG_RFCTL_SPI_CMD_DATA_TABLE_2: u32 = 0xa401c308;
pub const RPU_REG_RFCTL_SPI_READ_DATA_TABLE_0: u32 = 0xa401c380;
pub const PWR_CTRL1_SYSDEF: u32 = 0x1040;
pub const PWR_COUNTERSTART_SYSDEF: u32 = 0x1158;
pub const PWR_COUNTERCYCLES_SYSDEF: u32 = 0x1159;
pub const PWR_COUNTERSTATUS0_SYSDEF: u32 = 0x115c;
pub const PWR_COUNTERSTATUS1_SYSDEF: u32 = 0x115d;
pub const PWR_COUNTERSTATUS2_SYSDEF: u32 = 0x115e;
pub const PWR_COUNTERSTATUS3_SYSDEF: u32 = 0x115f;
pub const WL_PWR_MON_SYSDEF: u32 = 0x144;
pub const WL_PWR_AUX_SYSDEF: u32 = 0x145;
pub const PWR_BREAKTIMER90_SYSDEF: u32 = 0x1264;
pub const PWR_BREAKCOND2_SYSDEF: u32 = 0x1155;
pub const PWR_BREAK3_SYSDEF: u32 = 0x1150;
pub const PWR_BREAKCOND3_SYSDEF: u32 = 0x1156;
pub const PWR_BREAK5_SYSDEF: u32 = 0x1152;
pub const SPI_PAGESELECT: u32 = 0x7c;
pub const SPI_DIGREFCLOCKCTRL: u32 = 0x7d;
pub const RPU_REG_BIT_HARDRST_CTRL: u32 = 0x8;
pub const RPU_REG_BIT_PS_CTRL: u32 = 0x0;
pub const RPU_REG_BIT_PS_STATE: u32 = 0x1;
pub const RPU_REG_BIT_READY_STATE: u32 = 0x2;
pub const RPU_MEM_RX_CMD_BASE: u32 = 0xb7000d58;
pub const RPU_MEM_HPQ_INFO: u32 = 0xb0000024;
pub const RPU_MEM_TX_CMD_BASE: u32 = 0xb00000b8;
pub const RPU_MEM_OTP_INFO: u32 = 0xb000005c;
pub const RPU_MEM_OTP_INFO_FLAGS: u32 = 0xb0004fdc;
pub const RPU_MEM_LMAC_IF_INFO: u32 = 0xb0004fe0;
pub const RPU_MEM_PKT_BASE: u32 = 0xb0005000;
pub const RPU_CMD_START_MAGIC: u32 = 0xdead;
pub const RPU_DATA_CMD_SIZE_MAX_RX: u32 = 0x8;
pub const RPU_DATA_CMD_SIZE_MAX_TX: u32 = 0x94;
pub const RPU_EVENT_COMMON_SIZE_MAX: u32 = 0x80;
pub const EVENT_POOL_NUM_ELEMS: u32 = 0x7;
pub const MAX_EVENT_POOL_LEN: u32 = 0x3e8;
pub const MAX_NUM_OF_RX_QUEUES: u32 = 0x3;
pub const RPU_PWR_DATA_TYPE_LFC_ERR: u32 = 0x0;
pub const RPU_PWR_DATA_TYPE_VBAT_MON: u32 = 0x1;
pub const RPU_PWR_DATA_TYPE_TEMP: u32 = 0x2;
pub const RPU_PWR_DATA_TYPE_ALL: u32 = 0x3;
pub const RPU_PWR_DATA_TYPE_MAX: u32 = 0x4;
pub const RPU_RF_CLK_TYPE_20: u32 = 0x0;
pub const RPU_RF_CLK_TYPE_40: u32 = 0x1;
pub const RPU_RF_CLK_TYPE_MAX: u32 = 0x2;
pub const RPU_PKTRAM_SIZE: u32 = 0x2c000;
pub const REGION_PROTECT: u32 = 0x40;
pub const QSPI_KEY: u32 = 0x44;
pub const MAC0_ADDR: u32 = 0x48;
pub const MAC1_ADDR: u32 = 0x4a;
pub const CALIB_XO: u32 = 0x4c;
pub const CALIB_PDADJM7: u32 = 0x4d;
pub const CALIB_PDADJM0: u32 = 0x4e;
pub const CALIB_PWR2G: u32 = 0x4f;
pub const CALIB_PWR5GM7: u32 = 0x50;
pub const CALIB_PWR5GM0: u32 = 0x51;
pub const CALIB_RXGNOFF: u32 = 0x52;
pub const CALIB_TXPOWBACKOFFT: u32 = 0x53;
pub const CALIB_TXPOWBACKOFFV: u32 = 0x54;
pub const REGION_DEFAULTS: u32 = 0x55;
pub const OTP_MAX_WORD_LEN: u32 = 0x80;
pub const QSPI_KEY_LENGTH_BYTES: u32 = 0x10;
pub const OTP_SZ_CALIB_XO: u32 = 0x1;
pub const OTP_SZ_CALIB_PDADJM7: u32 = 0x4;
pub const OTP_SZ_CALIB_PDADJM0: u32 = 0x4;
pub const OTP_SZ_CALIB_PWR2G: u32 = 0x1;
pub const OTP_SZ_CALIB_PWR2GM0M7: u32 = 0x2;
pub const OTP_SZ_CALIB_PWR5GM7: u32 = 0x3;
pub const OTP_SZ_CALIB_PWR5GM0: u32 = 0x3;
pub const OTP_SZ_CALIB_RXGNOFF: u32 = 0x4;
pub const OTP_SZ_CALIB_TXP_BOFF_2GH: u32 = 0x1;
pub const OTP_SZ_CALIB_TXP_BOFF_2GL: u32 = 0x1;
pub const OTP_SZ_CALIB_TXP_BOFF_5GH: u32 = 0x1;
pub const OTP_SZ_CALIB_TXP_BOFF_5GL: u32 = 0x1;
pub const OTP_SZ_CALIB_TXP_BOFF_V: u32 = 0x4;
pub const OTP_OFF_CALIB_XO: u32 = 0x0;
pub const OTP_OFF_CALIB_PDADJM7: u32 = 0x4;
pub const OTP_OFF_CALIB_PDADJM0: u32 = 0x8;
pub const OTP_OFF_CALIB_PWR2G: u32 = 0xc;
pub const OTP_OFF_CALIB_PWR2GM0M7: u32 = 0xd;
pub const OTP_OFF_CALIB_PWR5GM7: u32 = 0x10;
pub const OTP_OFF_CALIB_PWR5GM0: u32 = 0x14;
pub const OTP_OFF_CALIB_RXGNOFF: u32 = 0x18;
pub const OTP_OFF_CALIB_TXP_BOFF_2GH: u32 = 0x1c;
pub const OTP_OFF_CALIB_TXP_BOFF_2GL: u32 = 0x1d;
pub const OTP_OFF_CALIB_TXP_BOFF_5GH: u32 = 0x1e;
pub const OTP_OFF_CALIB_TXP_BOFF_5GL: u32 = 0x1f;
pub const OTP_OFF_CALIB_TXP_BOFF_V: u32 = 0x20;
pub const QSPI_KEY_FLAG_MASK: i32 = -2;
pub const MAC0_ADDR_FLAG_MASK: i32 = -3;
pub const MAC1_ADDR_FLAG_MASK: i32 = -5;
pub const CALIB_XO_FLAG_MASK: i32 = -9;
pub const CALIB_PDADJM7_FLAG_MASK: i32 = -17;
pub const CALIB_PDADJM0_FLAG_MASK: i32 = -33;
pub const CALIB_PWR2G_FLAG_MASK: i32 = -65;
pub const CALIB_PWR5GM7_FLAG_MASK: i32 = -129;
pub const CALIB_PWR5GM0_FLAG_MASK: i32 = -257;
pub const CALIB_RXGNOFF_FLAG_MASK: i32 = -513;
pub const CALIB_TXPOWBACKOFFT_FLAG_MASK: i32 = -1025;
pub const CALIB_TXPOWBACKOFFV_FLAG_MASK: i32 = -2049;
pub const OTP_VOLTCTRL_ADDR: u32 = 0x19004;
pub const OTP_VOLTCTRL_2V5: u32 = 0x3b;
pub const OTP_VOLTCTRL_1V8: u32 = 0xb;
pub const OTP_POLL_ADDR: u32 = 0x1b804;
pub const OTP_WR_DONE: u32 = 0x1;
pub const OTP_READ_VALID: u32 = 0x2;
pub const OTP_READY: u32 = 0x4;
pub const OTP_RWSBMODE_ADDR: u32 = 0x1b800;
pub const OTP_STANDBY_MODE: u32 = 0x0;
pub const OTP_READ_MODE: u32 = 0x1;
pub const OTP_BYTE_WRITE_MODE: u32 = 0x42;
pub const OTP_RDENABLE_ADDR: u32 = 0x1b810;
pub const OTP_READREG_ADDR: u32 = 0x1b814;
pub const OTP_WRENABLE_ADDR: u32 = 0x1b808;
pub const OTP_WRITEREG_ADDR: u32 = 0x1b80c;
pub const OTP_TIMING_REG1_ADDR: u32 = 0x1b820;
pub const OTP_TIMING_REG1_VAL: u32 = 0x0;
pub const OTP_TIMING_REG2_ADDR: u32 = 0x1b824;
pub const OTP_TIMING_REG2_VAL: u32 = 0x30d8b;
pub const PRODTEST_TRIM_LEN: u32 = 0xf;
pub const OTP_FRESH_FROM_FAB: u32 = 0xffffffff;
pub const OTP_PROGRAMMED: u32 = 0x0;
pub const OTP_ENABLE_PATTERN: u32 = 0x50fa50fa;
pub const OTP_INVALID: u32 = 0xdeadbeef;
pub const BT_INIT: u32 = 0x1;
pub const BT_MODE: u32 = 0x2;
pub const BT_CTRL: u32 = 0x4;
pub const BT_COEX_DISABLE: u32 = 0x0;
pub const BT_COEX_ENABLE: u32 = 0x1;
pub const SLAVE: u32 = 0x0;
pub const MASTER: u32 = 0x1;
pub const RPU_MEM_UMAC_BOOT_SIG: u32 = 0xb0000000;
pub const RPU_MEM_UMAC_VER: u32 = 0xb0000004;
pub const RPU_MEM_UMAC_PEND_Q_BMP: u32 = 0xb0000008;
pub const RPU_MEM_UMAC_CMD_ADDRESS: u32 = 0xb00007a8;
pub const RPU_MEM_UMAC_EVENT_ADDRESS: u32 = 0xb0000e28;
pub const RPU_MEM_UMAC_PATCH_BIN: u32 = 0x8008c000;
pub const RPU_MEM_UMAC_PATCH_BIMG: u32 = 0x80094400;
pub const UMAC_BOOT_SIG: u32 = 0x5a5a5a5a;
pub const UMAC_ROM_PATCH_OFFSET: u32 = 0x14400;
pub const UMAC_BOOT_EXCP_VECT_0: u32 = 0x3c1a8000;
pub const UMAC_BOOT_EXCP_VECT_1: u32 = 0x275a0000;
pub const UMAC_BOOT_EXCP_VECT_2: u32 = 0x3400008;
pub const UMAC_BOOT_EXCP_VECT_3: u32 = 0x0;
pub const PENDING_FRAMES_BITMAP_AC_VO: u32 = 0x1;
pub const PENDING_FRAMES_BITMAP_AC_VI: u32 = 0x2;
pub const PENDING_FRAMES_BITMAP_AC_BE: u32 = 0x4;
pub const PENDING_FRAMES_BITMAP_AC_BK: u32 = 0x8;
pub const RF_PARAMS_SIZE: u32 = 0xc8;
pub const RF_PARAMS_CONF_SIZE: u32 = 0x2a;
pub const DEF_RF_PARAMS : & [u8 ; 311] = b"0000000000002A00000000030303035440403838383838380000000050EC000000FCFCF8FCF800000000007077003F032424001000002800323500000CF008087D8105010071630300EED501001F6F00003B350100F52E0000E35E0000B7B6000066EFFEFFB5F60000896200007A840200E28FFCFF080808080408120100000000A1A10178000000080050003B020726181818181A120A140E0600\0" ;
pub const RF_PARAMS_OFF_RESV_1: u32 = 0x0;
pub const RF_PARAMS_OFF_CALIB_X0: u32 = 0x6;
pub const RF_PARAMS_OFF_CALIB_PDADJM7: u32 = 0x7;
pub const RF_PARAMS_OFF_CALIB_PDADJM0: u32 = 0xb;
pub const RF_PARAMS_OFF_CALIB_PWR2G: u32 = 0xf;
pub const RF_PARAMS_OFF_CALIB_PWR2GM0M7: u32 = 0x10;
pub const RF_PARAMS_OFF_CALIB_PWR5GM7: u32 = 0x12;
pub const RF_PARAMS_OFF_CALIB_PWR5GM0: u32 = 0x15;
pub const RF_PARAMS_OFF_CALIB_RXGNOFF: u32 = 0x18;
pub const RF_PARAMS_OFF_CALIB_MAX_TEMP: u32 = 0x1c;
pub const RF_PARAMS_OFF_CALIB_MIN_TEMP: u32 = 0x1d;
pub const RF_PARAMS_OFF_CALIB_TXP_BOFF_2GH: u32 = 0x1e;
pub const RF_PARAMS_OFF_CALIB_TXP_BOFF_2GL: u32 = 0x1f;
pub const RF_PARAMS_OFF_CALIB_TXP_BOFF_5GH: u32 = 0x20;
pub const RF_PARAMS_OFF_CALIB_TXP_BOFF_5GL: u32 = 0x21;
pub const RF_PARAMS_OFF_CALIB_TXP_BOFF_V: u32 = 0x22;
pub const RF_PARAMS_OFF_CALIB_RESV_2: u32 = 0x25;
pub const PHY_CALIB_FLAG_RXDC: u32 = 0x1;
pub const PHY_CALIB_FLAG_TXDC: u32 = 0x2;
pub const PHY_CALIB_FLAG_TXPOW: u32 = 0x0;
pub const PHY_CALIB_FLAG_TXIQ: u32 = 0x8;
pub const PHY_CALIB_FLAG_RXIQ: u32 = 0x10;
pub const PHY_CALIB_FLAG_DPD: u32 = 0x20;
pub const PHY_SCAN_CALIB_FLAG_RXDC: u32 = 0x10000;
pub const PHY_SCAN_CALIB_FLAG_TXDC: u32 = 0x20000;
pub const PHY_SCAN_CALIB_FLAG_TXPOW: u32 = 0x0;
pub const PHY_SCAN_CALIB_FLAG_TXIQ: u32 = 0x0;
pub const PHY_SCAN_CALIB_FLAG_RXIQ: u32 = 0x0;
pub const PHY_SCAN_CALIB_FLAG_DPD: u32 = 0x0;
pub const DEF_PHY_CALIB: u32 = 0x3003b;
pub const DEF_PHY_TEMP_CALIB: u32 = 0x3b;
pub const TEMP_CALIB_PERIOD: u32 = 0x100000;
pub const TEMP_CALIB_THRESHOLD: u32 = 0x28;
pub const TEMP_CALIB_ENABLE: u32 = 0x1;
pub const DEF_PHY_VBAT_CALIB: u32 = 0x20;
pub const VBAT_VERYLOW: u32 = 0x3;
pub const VBAT_LOW: u32 = 0x6;
pub const VBAT_HIGH: u32 = 0xc;
pub const RPU_MEM_LMAC_BOOT_SIG: u32 = 0xb7000d50;
pub const RPU_MEM_LMAC_VER: u32 = 0xb7000d54;
pub const RPU_MEM_LMAC_PATCH_BIN: u32 = 0x80044000;
pub const RPU_MEM_LMAC_PATCH_BIMG: u32 = 0x80049000;
pub const LMAC_BOOT_SIG: u32 = 0x5a5a5a5a;
pub const LMAC_ROM_PATCH_OFFSET: u32 = 0x9000;
pub const LMAC_BOOT_EXCP_VECT_0: u32 = 0x3c1a8000;
pub const LMAC_BOOT_EXCP_VECT_1: u32 = 0x275a0000;
pub const LMAC_BOOT_EXCP_VECT_2: u32 = 0x3400008;
pub const LMAC_BOOT_EXCP_VECT_3: u32 = 0x0;
pub const LMAC_MAX_RX_BUFS: u32 = 0x100;
pub const HW_SLEEP_ENABLE: u32 = 0x2;
pub const SW_SLEEP_ENABLE: u32 = 0x1;
pub const SLEEP_DISABLE: u32 = 0x0;
pub const HW_DELAY: u32 = 0x1c84;
pub const SW_DELAY: u32 = 0x1388;
pub const BCN_TIMEOUT: u32 = 0x9c40;
pub const CALIB_SLEEP_CLOCK_ENABLE: u32 = 0x1;
pub const ACTIVE_SCAN_DURATION: u32 = 0x32;
pub const PASSIVE_SCAN_DURATION: u32 = 0x82;
pub const WORKING_CH_SCAN_DURATION: u32 = 0x32;
pub const CHNL_PROBE_CNT: u32 = 0x2;
pub const PKT_TYPE_MPDU: u32 = 0x0;
pub const PKT_TYPE_MSDU_WITH_MAC: u32 = 0x1;
pub const PKT_TYPE_MSDU: u32 = 0x2;
pub const RPU_PWR_STATUS_SUCCESS: u32 = 0x0;
pub const RPU_PWR_STATUS_FAIL: i32 = -1;
pub const MAX_RSSI_SAMPLES: u32 = 0xa;
pub const FREQ_2_4_GHZ: u32 = 0x1;
pub const FREQ_5_GHZ: u32 = 0x2;
pub const NUM_32_QUEUES: u32 = 0x4;
pub const USE_PROTECTION_NONE: u32 = 0x0;
pub const USE_PROTECTION_RTS: u32 = 0x1;
pub const USE_PROTECTION_CTS2SELF: u32 = 0x2;
pub const USE_SHORT_PREAMBLE: u32 = 0x0;
pub const DONT_USE_SHORT_PREAMBLE: u32 = 0x1;
pub const MARK_RATE_AS_MCS_INDEX: u32 = 0x80;
pub const MARK_RATE_AS_RATE: u32 = 0x0;
pub const ENABLE_GREEN_FIELD: u32 = 0x1;
pub const ENABLE_CHNL_WIDTH_40MHZ: u32 = 0x2;
pub const ENABLE_SGI: u32 = 0x4;
pub const ENABLE_11N_FORMAT: u32 = 0x8;
pub const ENABLE_VHT_FORMAT: u32 = 0x10;
pub const ENABLE_CHNL_WIDTH_80MHZ: u32 = 0x20;
pub const MAX_TX_AGG_SIZE: u32 = 0x10;
pub const MAX_RX_BUFS_PER_EVNT: u32 = 0x40;
pub const MAX_MGMT_BUFS: u32 = 0x10;
pub const MAX_RF_CALIB_DATA: u32 = 0x384;
pub const ETH_ADDR_LEN: u32 = 0x6;
pub const PHY_THRESHOLD_NORMAL: i32 = -65;
pub const PHY_THRESHOLD_PROD_MODE: i32 = -93;
pub const MAX_TX_STREAMS: u32 = 0x1;
pub const MAX_RX_STREAMS: u32 = 0x1;
pub const MAX_NUM_VIFS: u32 = 0x2;
pub const MAX_NUM_STAS: u32 = 0x2;
pub const MAX_NUM_APS: u32 = 0x1;
pub const COUNTRY_CODE_LEN: u32 = 0x2;
pub const FEATURE_DISABLE: u32 = 0x0;
pub const FEATURE_ENABLE: u32 = 0x1;
pub const HE_GI_800NS: u32 = 0x0;
pub const HE_GI_1600NS: u32 = 0x1;
pub const HE_GI_3200NS: u32 = 0x2;
pub const HE_LTF_3200NS: u32 = 0x0;
pub const HE_LTF_6400NS: u32 = 0x1;
pub const HE_LTF_12800NS: u32 = 0x2;
pub const DISABLE: u32 = 0x0;
pub const ENABLE: u32 = 0x1;
pub const TX_BUF_HEADROOM: u32 = 0x34;
pub const TX_STATUS_SUCCESS: u32 = 0x0;
pub const TX_STATUS_FAILED: u32 = 0x1;
pub const CLIENT_ACTIVE: u32 = 0x0;
pub const CLIENT_PS_MODE: u32 = 0x1;
pub const MAX_UMAC_CMD_SIZE: u32 = 0x190;
pub const IMG_UMAC_EVENT_MCAST_FILTER: u32 = 0x12a;
pub const MAX_SSID_LEN: u32 = 0x20;
pub const MAX_IE_LEN: u32 = 0x190;
pub const MAX_SEQ_LENGTH: u32 = 0x100;
pub const MAX_KEY_LENGTH: u32 = 0x100;
pub const MAX_SAE_DATA_LENGTH: u32 = 0x100;
pub const MAX_FRAME_LEN: u32 = 0x190;
pub const INDEX_IDS_WDEV_ID_VALID: u32 = 0x1;
pub const INDEX_IDS_IFINDEX_VALID: u32 = 0x2;
pub const INDEX_IDS_WIPHY_IDX_VALID: u32 = 0x4;
pub const SUPP_RATES_BAND_VALID: u32 = 0x1;
pub const MAX_SUPP_RATES: u32 = 0x3c;
pub const SCAN_PARAMS_2GHZ_BAND_VALID: u32 = 0x1;
pub const SCAN_PARAMS_5GHZ_BAND_VALID: u32 = 0x2;
pub const SCAN_PARAMS_60GHZ_BAND_VALID: u32 = 0x4;
pub const SCAN_PARAMS_MAC_ADDR_VALID: u32 = 0x8;
pub const SCAN_PARAMS_MAC_ADDR_MASK_VALID: u32 = 0x10;
pub const SCAN_PARAMS_SCAN_FLAGS_VALID: u32 = 0x20;
pub const SCAN_PARAMS_SUPPORTED_RATES_VALID: u32 = 0x40;
pub const SCAN_MAX_NUM_SSIDS: u32 = 0x2;
pub const SCAN_MAX_NUM_FREQUENCIES: u32 = 0x40;
pub const MAX_NUM_CHANNELS: u32 = 0x2a;
pub const SCAN_FLAG_LOW_PRIORITY: u32 = 0x1;
pub const SCAN_FLAG_FLUSH: u32 = 0x2;
pub const SCAN_FLAG_AP: u32 = 0x4;
pub const SCAN_FLAG_RANDOM_ADDR: u32 = 0x8;
pub const SCAN_FLAG_FILS_MAX_CHANNEL_TIME: u32 = 0x10;
pub const SCAN_FLAG_ACCEPT_BCAST_PROBE_RESP: u32 = 0x20;
pub const SCAN_FLAG_OCE_PROBE_REQ_HIGH_TX_RATE: u32 = 0x40;
pub const SCAN_FLAG_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION: u32 = 0x80;
pub const SCAN_FLAG_LOW_SPAN: u32 = 0x100;
pub const SCAN_FLAG_LOW_POWER: u32 = 0x200;
pub const SCAN_FLAG_HIGH_ACCURACY: u32 = 0x400;
pub const SCAN_FLAG_RANDOM_SN: u32 = 0x800;
pub const SCAN_FLAG_MIN_PREQ_CONTENT: u32 = 0x1000;
pub const HT_CAPABILITY_VALID: u32 = 0x1;
pub const HT_CAPABILITY_MASK_VALID: u32 = 0x2;
pub const VHT_CAPABILITY_VALID: u32 = 0x4;
pub const VHT_CAPABILITY_MASK_VALID: u32 = 0x8;
pub const CMD_HT_VHT_CAPABILITY_DISABLE_HT: u32 = 0x1;
pub const HT_VHT_CAPABILITY_MAX_SIZE: u32 = 0x100;
pub const SIGNAL_TYPE_NONE: u32 = 0x1;
pub const SIGNAL_TYPE_MBM: u32 = 0x2;
pub const SIGNAL_TYPE_UNSPEC: u32 = 0x3;
pub const WPA_VERSION_1: u32 = 0x1;
pub const WPA_VERSION_2: u32 = 0x2;
pub const CONNECT_COMMON_INFO_MAC_ADDR_VALID: u32 = 0x1;
pub const CONNECT_COMMON_INFO_MAC_ADDR_HINT_VALID: u32 = 0x2;
pub const CONNECT_COMMON_INFO_FREQ_VALID: u32 = 0x4;
pub const CONNECT_COMMON_INFO_FREQ_HINT_VALID: u32 = 0x8;
pub const CONNECT_COMMON_INFO_BG_SCAN_PERIOD_VALID: u32 = 0x10;
pub const CONNECT_COMMON_INFO_SSID_VALID: u32 = 0x20;
pub const CONNECT_COMMON_INFO_WPA_IE_VALID: u32 = 0x40;
pub const CONNECT_COMMON_INFO_WPA_VERSIONS_VALID: u32 = 0x80;
pub const CONNECT_COMMON_INFO_CIPHER_SUITES_PAIRWISE_VALID: u32 = 0x100;
pub const CONNECT_COMMON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 0x200;
pub const CONNECT_COMMON_INFO_AKM_SUITES_VALID: u32 = 0x400;
pub const CONNECT_COMMON_INFO_USE_MFP_VALID: u32 = 0x800;
pub const CONNECT_COMMON_INFO_CONTROL_PORT_ETHER_TYPE: u32 = 0x1000;
pub const CONNECT_COMMON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 0x2000;
pub const MAX_NR_AKM_SUITES: u32 = 0x2;
pub const CMD_CONNECT_COMMON_INFO_USE_RRM: u32 = 0x4000;
pub const CONNECT_COMMON_INFO_PREV_BSSID: u32 = 0x8000;
pub const BEACON_DATA_MAX_HEAD_LEN: u32 = 0x100;
pub const BEACON_DATA_MAX_TAIL_LEN: u32 = 0x200;
pub const BEACON_DATA_MAX_PROBE_RESP_LEN: u32 = 0x190;
pub const RATE_INFO_BITRATE_VALID: u32 = 0x1;
pub const RATE_INFO_BITRATE_COMPAT_VALID: u32 = 0x2;
pub const RATE_INFO_BITRATE_MCS_VALID: u32 = 0x4;
pub const RATE_INFO_BITRATE_VHT_MCS_VALID: u32 = 0x8;
pub const RATE_INFO_BITRATE_VHT_NSS_VALID: u32 = 0x10;
pub const RATE_INFO_0_MHZ_WIDTH: u32 = 0x1;
pub const RATE_INFO_5_MHZ_WIDTH: u32 = 0x2;
pub const RATE_INFO_10_MHZ_WIDTH: u32 = 0x4;
pub const RATE_INFO_40_MHZ_WIDTH: u32 = 0x8;
pub const RATE_INFO_80_MHZ_WIDTH: u32 = 0x10;
pub const RATE_INFO_160_MHZ_WIDTH: u32 = 0x20;
pub const RATE_INFO_SHORT_GI: u32 = 0x40;
pub const RATE_INFO_80P80_MHZ_WIDTH: u32 = 0x80;
pub const STA_INFO_CONNECTED_TIME_VALID: u32 = 0x1;
pub const STA_INFO_INACTIVE_TIME_VALID: u32 = 0x2;
pub const STA_INFO_RX_BYTES_VALID: u32 = 0x4;
pub const STA_INFO_TX_BYTES_VALID: u32 = 0x8;
pub const STA_INFO_CHAIN_SIGNAL_VALID: u32 = 0x10;
pub const STA_INFO_CHAIN_SIGNAL_AVG_VALID: u32 = 0x20;
pub const STA_INFO_TX_BITRATE_VALID: u32 = 0x40;
pub const STA_INFO_RX_BITRATE_VALID: u32 = 0x80;
pub const STA_INFO_STA_FLAGS_VALID: u32 = 0x100;
pub const STA_INFO_LLID_VALID: u32 = 0x200;
pub const STA_INFO_PLID_VALID: u32 = 0x400;
pub const STA_INFO_PLINK_STATE_VALID: u32 = 0x800;
pub const STA_INFO_SIGNAL_VALID: u32 = 0x1000;
pub const STA_INFO_SIGNAL_AVG_VALID: u32 = 0x2000;
pub const STA_INFO_RX_PACKETS_VALID: u32 = 0x4000;
pub const STA_INFO_TX_PACKETS_VALID: u32 = 0x8000;
pub const STA_INFO_TX_RETRIES_VALID: u32 = 0x10000;
pub const STA_INFO_TX_FAILED_VALID: u32 = 0x20000;
pub const STA_INFO_EXPECTED_THROUGHPUT_VALID: u32 = 0x40000;
pub const STA_INFO_BEACON_LOSS_COUNT_VALID: u32 = 0x80000;
pub const STA_INFO_LOCAL_PM_VALID: u32 = 0x100000;
pub const STA_INFO_PEER_PM_VALID: u32 = 0x200000;
pub const STA_INFO_NONPEER_PM_VALID: u32 = 0x400000;
pub const STA_INFO_T_OFFSET_VALID: u32 = 0x800000;
pub const STA_INFO_RX_DROPPED_MISC_VALID: u32 = 0x1000000;
pub const STA_INFO_RX_BEACON_VALID: u32 = 0x2000000;
pub const STA_INFO_RX_BEACON_SIGNAL_AVG_VALID: u32 = 0x4000000;
pub const STA_INFO_STA_BSS_PARAMS_VALID: u32 = 0x8000000;
pub const IEEE80211_MAX_CHAINS: u32 = 0x4;
pub const KEY_VALID: u32 = 0x1;
pub const KEY_TYPE_VALID: u32 = 0x2;
pub const KEY_IDX_VALID: u32 = 0x4;
pub const SEQ_VALID: u32 = 0x8;
pub const CIPHER_SUITE_VALID: u32 = 0x10;
pub const KEY_INFO_VALID: u32 = 0x20;
pub const KEY_DEFAULT: u32 = 0x1;
pub const KEY_DEFAULT_TYPES: u32 = 0x2;
pub const KEY_DEFAULT_MGMT: u32 = 0x4;
pub const KEY_DEFAULT_TYPE_UNICAST: u32 = 0x8;
pub const KEY_DEFAULT_TYPE_MULTICAST: u32 = 0x10;
pub const CMD_GET_KEY_MAC_ADDR_VALID: u32 = 0x1;
pub const CMD_GET_KEY_KEY_IDX_VALID: u32 = 0x2;
pub const EVENT_GET_KEY_MAC_ADDR_VALID: u32 = 0x1;
pub const MCAST_ADDR_ADD: u32 = 0x0;
pub const MCAST_ADDR_DEL: u32 = 0x1;
pub const CMD_AUTHENTICATE_KEY_INFO_VALID: u32 = 0x1;
pub const CMD_AUTHENTICATE_BSSID_VALID: u32 = 0x2;
pub const CMD_AUTHENTICATE_FREQ_VALID: u32 = 0x4;
pub const CMD_AUTHENTICATE_SSID_VALID: u32 = 0x8;
pub const CMD_AUTHENTICATE_IE_VALID: u32 = 0x10;
pub const CMD_AUTHENTICATE_SAE_VALID: u32 = 0x20;
pub const CMD_AUTHENTICATE_LOCAL_STATE_CHANGE: u32 = 0x1;
pub const CMD_ASSOCIATE_MAC_ADDR_VALID: u32 = 0x1;
pub const CMD_MLME_MAC_ADDR_VALID: u32 = 0x1;
pub const CMD_MLME_LOCAL_STATE_CHANGE: u32 = 0x1;
pub const CMD_NEW_INTERFACE_USE_4ADDR_VALID: u32 = 0x1;
pub const CMD_NEW_INTERFACE_MAC_ADDR_VALID: u32 = 0x2;
pub const CMD_NEW_INTERFACE_IFTYPE_VALID: u32 = 0x4;
pub const CMD_NEW_INTERFACE_IFNAME_VALID: u32 = 0x8;
pub const FRAME_MATCH_MAX_LEN: u32 = 0x8;
pub const CMD_KEY_MAC_ADDR_VALID: u32 = 0x1;
pub const CMD_SET_BSS_CTS_VALID: u32 = 0x1;
pub const CMD_SET_BSS_PREAMBLE_VALID: u32 = 0x2;
pub const CMD_SET_BSS_SLOT_VALID: u32 = 0x4;
pub const CMD_SET_BSS_HT_OPMODE_VALID: u32 = 0x8;
pub const CMD_SET_BSS_AP_ISOLATE_VALID: u32 = 0x10;
pub const CMD_SET_BSS_P2P_CTWINDOW_VALID: u32 = 0x20;
pub const CMD_SET_BSS_P2P_OPPPS_VALID: u32 = 0x40;
pub const BASIC_MAX_SUPP_RATES: u32 = 0x20;
pub const SET_FREQ_PARAMS_FREQ_VALID: u32 = 0x1;
pub const SET_FREQ_PARAMS_CHANNEL_WIDTH_VALID: u32 = 0x2;
pub const SET_FREQ_PARAMS_CENTER_FREQ1_VALID: u32 = 0x4;
pub const SET_FREQ_PARAMS_CENTER_FREQ2_VALID: u32 = 0x8;
pub const SET_FREQ_PARAMS_CHANNEL_TYPE_VALID: u32 = 0x10;
pub const CMD_SET_CHANNEL_FREQ_PARAMS_VALID: u32 = 0x1;
pub const TX_POWER_SETTING_TYPE_VALID: u32 = 0x1;
pub const TX_POWER_SETTING_TX_POWER_LEVEL_VALID: u32 = 0x2;
pub const CMD_SET_WIPHY_FREQ_PARAMS_VALID: u32 = 0x1;
pub const CMD_SET_WIPHY_TXQ_PARAMS_VALID: u32 = 0x2;
pub const CMD_SET_WIPHY_RTS_THRESHOLD_VALID: u32 = 0x4;
pub const CMD_SET_WIPHY_FRAG_THRESHOLD_VALID: u32 = 0x8;
pub const CMD_SET_WIPHY_TX_POWER_SETTING_VALID: u32 = 0x10;
pub const CMD_SET_WIPHY_ANTENNA_TX_VALID: u32 = 0x20;
pub const CMD_SET_WIPHY_ANTENNA_RX_VALID: u32 = 0x40;
pub const CMD_SET_WIPHY_RETRY_SHORT_VALID: u32 = 0x80;
pub const CMD_SET_WIPHY_RETRY_LONG_VALID: u32 = 0x100;
pub const CMD_SET_WIPHY_COVERAGE_CLASS_VALID: u32 = 0x200;
pub const CMD_SET_WIPHY_WIPHY_NAME_VALID: u32 = 0x400;
pub const CMD_DEL_STATION_MAC_ADDR_VALID: u32 = 0x1;
pub const CMD_DEL_STATION_MGMT_SUBTYPE_VALID: u32 = 0x2;
pub const CMD_DEL_STATION_REASON_CODE_VALID: u32 = 0x4;
pub const EXT_CAPABILITY_MAX_LEN: u32 = 0x20;
pub const SUPPORTED_CHANNELS_MAX_LEN: u32 = 0x40;
pub const SUPPORTED_OPER_CLASSES_MAX_LEN: u32 = 0x40;
pub const STA_FLAGS2_MAX_LEN: u32 = 0x40;
pub const CMD_SET_STATION_SUPP_RATES_VALID: u32 = 0x1;
pub const CMD_SET_STATION_AID_VALID: u32 = 0x2;
pub const CMD_SET_STATION_PEER_AID_VALID: u32 = 0x4;
pub const CMD_SET_STATION_STA_CAPABILITY_VALID: u32 = 0x8;
pub const CMD_SET_STATION_EXT_CAPABILITY_VALID: u32 = 0x10;
pub const CMD_SET_STATION_STA_VLAN_VALID: u32 = 0x20;
pub const CMD_SET_STATION_HT_CAPABILITY_VALID: u32 = 0x40;
pub const CMD_SET_STATION_VHT_CAPABILITY_VALID: u32 = 0x80;
pub const CMD_SET_STATION_OPMODE_NOTIF_VALID: u32 = 0x200;
pub const CMD_SET_STATION_SUPPORTED_CHANNELS_VALID: u32 = 0x400;
pub const CMD_SET_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 0x800;
pub const CMD_SET_STATION_STA_FLAGS2_VALID: u32 = 0x1000;
pub const CMD_SET_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 0x2000;
pub const CMD_SET_STATION_STA_WME_MAX_SP_VALID: u32 = 0x4000;
pub const CMD_SET_STATION_LISTEN_INTERVAL_VALID: u32 = 0x8000;
pub const CMD_NEW_STATION_SUPP_RATES_VALID: u32 = 0x1;
pub const CMD_NEW_STATION_AID_VALID: u32 = 0x2;
pub const CMD_NEW_STATION_PEER_AID_VALID: u32 = 0x4;
pub const CMD_NEW_STATION_STA_CAPABILITY_VALID: u32 = 0x8;
pub const CMD_NEW_STATION_EXT_CAPABILITY_VALID: u32 = 0x10;
pub const CMD_NEW_STATION_STA_VLAN_VALID: u32 = 0x20;
pub const CMD_NEW_STATION_HT_CAPABILITY_VALID: u32 = 0x40;
pub const CMD_NEW_STATION_VHT_CAPABILITY_VALID: u32 = 0x80;
pub const CMD_NEW_STATION_OPMODE_NOTIF_VALID: u32 = 0x200;
pub const CMD_NEW_STATION_SUPPORTED_CHANNELS_VALID: u32 = 0x400;
pub const CMD_NEW_STATION_SUPPORTED_OPER_CLASSES_VALID: u32 = 0x800;
pub const CMD_NEW_STATION_STA_FLAGS2_VALID: u32 = 0x1000;
pub const CMD_NEW_STATION_STA_WME_UAPSD_QUEUES_VALID: u32 = 0x2000;
pub const CMD_NEW_STATION_STA_WME_MAX_SP_VALID: u32 = 0x4000;
pub const CMD_NEW_STATION_LISTEN_INTERVAL_VALID: u32 = 0x8000;
pub const CMD_BEACON_INFO_BEACON_INTERVAL_VALID: u32 = 0x1;
pub const CMD_BEACON_INFO_AUTH_TYPE_VALID: u32 = 0x2;
pub const CMD_BEACON_INFO_VERSIONS_VALID: u32 = 0x4;
pub const CMD_BEACON_INFO_CIPHER_SUITE_GROUP_VALID: u32 = 0x8;
pub const CMD_BEACON_INFO_INACTIVITY_TIMEOUT_VALID: u32 = 0x10;
pub const CMD_BEACON_INFO_FREQ_PARAMS_VALID: u32 = 0x20;
pub const CMD_BEACON_INFO_PRIVACY: u32 = 0x1;
pub const CMD_BEACON_INFO_CONTROL_PORT_NO_ENCRYPT: u32 = 0x2;
pub const CMD_BEACON_INFO_P2P_CTWINDOW_VALID: u32 = 0x40;
pub const CMD_BEACON_INFO_P2P_OPPPS_VALID: u32 = 0x80;
pub const SET_INTERFACE_IFTYPE_VALID: u32 = 0x1;
pub const SET_INTERFACE_USE_4ADDR_VALID: u32 = 0x2;
pub const IFACENAMSIZ: u32 = 0x10;
pub const CMD_FRAME_FREQ_VALID: u32 = 0x1;
pub const CMD_FRAME_DURATION_VALID: u32 = 0x2;
pub const CMD_SET_FRAME_FREQ_PARAMS_VALID: u32 = 0x4;
pub const CMD_FRAME_OFFCHANNEL_TX_OK: u32 = 0x1;
pub const CMD_FRAME_TX_NO_CCK_RATE: u32 = 0x2;
pub const CMD_FRAME_DONT_WAIT_FOR_ACK: u32 = 0x4;
pub const SET_WOWLAN_FLAG_TRIG_ANY: u32 = 0x1;
pub const SET_WOWLAN_FLAG_TRIG_DISCONNECT: u32 = 0x2;
pub const SET_WOWLAN_FLAG_TRIG_MAGIC_PKT: u32 = 0x4;
pub const SET_WOWLAN_FLAG_TRIG_GTK_REKEY_FAILURE: u32 = 0x8;
pub const SET_WOWLAN_FLAG_TRIG_EAP_IDENT_REQUEST: u32 = 0x10;
pub const SET_WOWLAN_FLAG_TRIG_4WAY_HANDSHAKE: u32 = 0x20;
pub const TWT_NEGOTIATION_TYPE_INDIVIDUAL: u32 = 0x0;
pub const TWT_NEGOTIATION_TYPE_BROADCAST: u32 = 0x2;
pub const TWT_FLOW_TYPE_ANNOUNCED: u32 = 0x0;
pub const TWT_FLOW_TYPE_UNANNOUNCED: u32 = 0x1;
pub const TWT_RESP_RECEIVED: u32 = 0x0;
pub const TWT_RESP_NOT_RECEIVED: u32 = 0x1;
pub const INVALID_TIME: u32 = 0x1;
pub const TRIGGER_NOT_RECEIVED: u32 = 0x2;
pub const TWT_BLOCK_TX: u32 = 0x0;
pub const TWT_UNBLOCK_TX: u32 = 0x1;
pub const UAPSD_Q_MIN: u32 = 0x0;
pub const UAPSD_Q_MAX: u32 = 0xf;
pub const EVENT_NEW_SCAN_RESULTS_MAC_ADDR_VALID: u32 = 0x1;
pub const EVENT_NEW_SCAN_RESULTS_IES_TSF_VALID: u32 = 0x2;
pub const EVENT_NEW_SCAN_RESULTS_IES_VALID: u32 = 0x4;
pub const EVENT_NEW_SCAN_RESULTS_BEACON_IES_TSF_VALID: u32 = 0x8;
pub const EVENT_NEW_SCAN_RESULTS_BEACON_IES_VALID: u32 = 0x10;
pub const EVENT_NEW_SCAN_RESULTS_BEACON_INTERVAL_VALID: u32 = 0x20;
pub const EVENT_NEW_SCAN_RESULTS_SIGNAL_VALID: u32 = 0x40;
pub const EVENT_NEW_SCAN_RESULTS_STATUS_VALID: u32 = 0x80;
pub const EVENT_NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 0x100;
pub const NEW_SCAN_RESULTS_BSS_PRESP_DATA: u32 = 0x1;
pub const IEEE_802_11A: u32 = 0x1;
pub const IEEE_802_11B: u32 = 0x2;
pub const IEEE_802_11G: u32 = 0x4;
pub const IEEE_802_11N: u32 = 0x8;
pub const IEEE_802_11AC: u32 = 0x10;
pub const IEEE_802_11AX: u32 = 0x20;
pub const MFP_REQUIRED: u32 = 0x1;
pub const MFP_CAPABLE: u32 = 0x2;
pub const DISPLAY_BSS_TOHOST_PEREVNT: u32 = 0x8;
pub const EVENT_MLME_FRAME_VALID: u32 = 0x1;
pub const EVENT_MLME_MAC_ADDR_VALID: u32 = 0x2;
pub const EVENT_MLME_FREQ_VALID: u32 = 0x4;
pub const EVENT_MLME_COOKIE_VALID: u32 = 0x8;
pub const EVENT_MLME_RX_SIGNAL_DBM_VALID: u32 = 0x10;
pub const EVENT_MLME_WME_UAPSD_QUEUES_VALID: u32 = 0x20;
pub const EVENT_MLME_RXMGMT_FLAGS_VALID: u32 = 0x40;
pub const EVENT_MLME_IE_VALID: u32 = 0x80;
pub const EVENT_MLME_TIMED_OUT: u32 = 0x1;
pub const EVENT_MLME_ACK: u32 = 0x2;
pub const EVENT_CONNECT_STATUS_CODE_VALID: u32 = 0x1;
pub const EVENT_CONNECT_MAC_ADDR_VALID: u32 = 0x2;
pub const EVENT_CONNECT_REQ_IE_VALID: u32 = 0x4;
pub const EVENT_CONNECT_RESP_IE_VALID: u32 = 0x8;
pub const EVENT_CONNECT_AUTHORIZED_VALID: u32 = 0x10;
pub const EVENT_CONNECT_KEY_REPLAY_CTR_VALID: u32 = 0x20;
pub const EVENT_CONNECT_PTK_KCK_VALID: u32 = 0x40;
pub const EVENT_CONNECT_PTK_KEK_VALID: u32 = 0x80;
pub const CMD_SEND_STATION_ASSOC_REQ_IES_VALID: u32 = 0x1;
pub const CMD_COOKIE_RSP_COOKIE_VALID: u32 = 0x1;
pub const CMD_COOKIE_RSP_MAC_ADDR_VALID: u32 = 0x2;
pub const MAX_TWT_FLOWS: u32 = 0x8;
pub const PS_MODE_LEGACY: u32 = 0x0;
pub const PS_MODE_WMM: u32 = 0x1;
pub const LISTEN_INTERVAL_MIN: u32 = 0x3;
pub const TX_BITRATE_MASK_LEGACY_MAX_LEN: u32 = 0x8;
pub const IEEE80211_HT_MCS_MASK_LEN: u32 = 0xa;
pub const VHT_NSS_MAX: u32 = 0x8;
pub const SET_TX_BITRATE_MASK_BAND_2GHZ_VALID: u32 = 0x1;
pub const SET_TX_BITRATE_MASK_BAND_5GHZ_VALID: u32 = 0x2;
pub const SET_TX_BITRATE_MASK_BAND_60GHZ_VALID: u32 = 0x4;
pub const EVENT_TRIGGER_SCAN_IE_VALID: u32 = 0x1;
pub const EVENT_TRIGGER_SCAN_SCAN_FLAGS_VALID: u32 = 0x2;
pub const CMD_ROC_FREQ_PARAMS_VALID: u32 = 0x1;
pub const CMD_ROC_DURATION_VALID: u32 = 0x2;
pub const CMD_CANCEL_ROC_COOKIE_VALID: u32 = 0x1;
pub const EVENT_ROC_FREQ_VALID: u32 = 0x1;
pub const EVENT_ROC_COOKIE_VALID: u32 = 0x2;
pub const EVENT_ROC_DURATION_VALID: u32 = 0x4;
pub const EVENT_ROC_CH_TYPE_VALID: u32 = 0x8;
pub const INTERFACE_INFO_CHAN_DEF_VALID: u32 = 0x1;
pub const INTERFACE_INFO_SSID_VALID: u32 = 0x2;
pub const INTERFACE_INFO_IFNAME_VALID: u32 = 0x4;
pub const HT_MCS_MASK_LEN: u32 = 0xa;
pub const HT_MCS_RES_LEN: u32 = 0x3;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_IR: u32 = 0x1;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_IBSS: u32 = 0x2;
pub const CHAN_FLAG_FREQUENCY_ATTR_RADAR: u32 = 0x4;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_MINUS: u32 = 0x8;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_HT40_PLUS: u32 = 0x10;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_80MHZ: u32 = 0x20;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_160MHZ: u32 = 0x40;
pub const CHAN_FLAG_FREQUENCY_ATTR_INDOOR_ONLY: u32 = 0x80;
pub const CHAN_FLAG_FREQUENCY_ATTR_GO_CONCURRENT: u32 = 0x100;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_20MHZ: u32 = 0x200;
pub const CHAN_FLAG_FREQUENCY_ATTR_NO_10MHZ: u32 = 0x400;
pub const CHAN_FLAG_FREQUENCY_DISABLED: u32 = 0x800;
pub const CHAN_DFS_VALID: u32 = 0x1000;
pub const CHAN_DFS_CAC_TIME_VALID: u32 = 0x2000;
pub const EVENT_GET_WIPHY_FLAG_RATE_SHORT_PREAMBLE: u32 = 0x1;
pub const EVENT_GET_WIPHY_VALID_RADAR_DETECT_WIDTHS: u32 = 0x1;
pub const EVENT_GET_WIPHY_VALID_RADAR_DETECT_REGIONS: u32 = 0x2;
pub const EVENT_GET_WIPHY_VALID_: u32 = 0x4;
pub const EVENT_GET_WIPHY_MAX_CIPHER_COUNT: u32 = 0x1e;
pub const EVENT_GET_WIPHY_IBSS_RSN: u32 = 0x1;
pub const EVENT_GET_WIPHY_MESH_AUTH: u32 = 0x2;
pub const EVENT_GET_WIPHY_AP_UAPSD: u32 = 0x4;
pub const EVENT_GET_WIPHY_SUPPORTS_FW_ROAM: u32 = 0x8;
pub const EVENT_GET_WIPHY_SUPPORTS_TDLS: u32 = 0x10;
pub const EVENT_GET_WIPHY_TDLS_EXTERNAL_SETUP: u32 = 0x20;
pub const EVENT_GET_WIPHY_CONTROL_PORT_ETHERTYPE: u32 = 0x40;
pub const EVENT_GET_WIPHY_OFFCHANNEL_TX_OK: u32 = 0x80;
pub const GET_WIPHY_VALID_PROBE_RESP_OFFLOAD: u32 = 0x1;
pub const GET_WIPHY_VALID_TX_ANT: u32 = 0x2;
pub const GET_WIPHY_VALID_RX_ANT: u32 = 0x4;
pub const GET_WIPHY_VALID_MAX_NUM_SCAN_SSIDS: u32 = 0x8;
pub const GET_WIPHY_VALID_NUM_SCHED_SCAN_SSIDS: u32 = 0x10;
pub const GET_WIPHY_VALID_MAX_MATCH_SETS: u32 = 0x20;
pub const GET_WIPHY_VALID_MAC_ACL_MAX: u32 = 0x40;
pub const GET_WIPHY_VALID_HAVE_AP_SME: u32 = 0x80;
pub const GET_WIPHY_VALID_EXTENDED_CAPABILITIES: u32 = 0x100;
pub const GET_WIPHY_VALID_MAX_AP_ASSOC_STA: u32 = 0x200;
pub const GET_WIPHY_VALID_WIPHY_NAME: u32 = 0x400;
pub const GET_WIPHY_VALID_EXTENDED_FEATURES: u32 = 0x800;
pub const EXTENDED_FEATURE_LEN: u32 = 0x3c;
pub const INDEX_IDS_WIPHY_NAME: u32 = 0x20;
pub const EVENT_GET_WIPHY_NUM_BANDS: u32 = 0x2;
pub const REG_RULE_FLAGS_VALID: u32 = 0x1;
pub const FREQ_RANGE_START_VALID: u32 = 0x2;
pub const FREQ_RANGE_END_VALID: u32 = 0x4;
pub const FREQ_RANGE_MAX_BW_VALID: u32 = 0x8;
pub const POWER_RULE_MAX_EIRP_VALID: u32 = 0x10;
pub const CMD_SET_REG_ALPHA2_VALID: u32 = 0x1;
pub const CMD_SET_REG_RULES_VALID: u32 = 0x2;
pub const CMD_SET_REG_DFS_REGION_VALID: u32 = 0x4;
pub const MAX_NUM_REG_RULES: u32 = 0x20;
pub const CMD_REQ_SET_REG_ALPHA2_VALID: u32 = 0x1;
pub const CMD_REQ_SET_REG_USER_REG_HINT_TYPE_VALID: u32 = 0x2;
pub const CMD_REQ_SET_REG_USER_REG_FORCE: u32 = 0x4;
pub const EVNT_WIPHY_SELF_MANAGED: u32 = 0x1;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum RPU_MCU_ADDR_REGIONS {
    RPU_MCU_ADDR_REGION_ROM = 0,
    RPU_MCU_ADDR_REGION_RETENTION = 1,
    RPU_MCU_ADDR_REGION_SCRATCH = 2,
    RPU_MCU_ADDR_REGION_MAX = 3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_region {
    pub start: ::core::ffi::c_uint,
    pub end: ::core::ffi::c_uint,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_addr_map {
    pub regions: [rpu_addr_region; 3usize],
}
extern "C" {
    pub static RPU_ADDR_MAP_MCU: [rpu_addr_map; 2usize];
}
#[doc = " struct rpu_pwr_data - Data that host may want to read from the Power IP.\n @lfc_err: Estimated Lo Frequency Clock error in ppm.\n @vbat_mon: Vbat monitor readout. The actual Vbat in volt equals 2.5 + 0.07*vbat_mon.\n @temp: Estimated die temperature (degC).\n\n This structure represents the Power IP monitoring data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_pwr_data {
    pub lfc_err: ::core::ffi::c_int,
    pub vbat_mon: ::core::ffi::c_int,
    pub temp: ::core::ffi::c_int,
}
#[doc = " struct host_rpu_rx_buf_info - RX buffer related information to be passed to\n                               the RPU.\n @addr: Address in the host memory where the RX buffer is located.\n\n This structure encapsulates the information to be passed to the RPU for\n buffers which the RPU will use to pass the received frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_rx_buf_info {
    pub addr: ::core::ffi::c_uint,
}
#[doc = " struct host_rpu_hpq - Hostport Queue (HPQ) information.\n @enqueue_addr: HPQ address where the host can post the address of a\n                message intended for the RPU.\n @dequeue_addr: HPQ address where the host can get the address of a\n                message intended for the host.\n\n This structure encapsulates the information which represents a HPQ."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpq {
    pub enqueue_addr: ::core::ffi::c_uint,
    pub dequeue_addr: ::core::ffi::c_uint,
}
#[doc = " struct host_rpu_hpqm_info - Information about Hostport Queues (HPQ) to be used\n            for exchanging information between the Host and RPU.\n @event_busy_queue: Queue which the RPU uses to inform the host about events.\n @event_avl_queue: Queue on which the consumed events are pushed so that RPU\n                    can reuse them.\n @cmd_busy_queue: Queue used by the host to push commands to the RPU.\n @cmd_avl_queue: Queue which RPU uses to inform host about command\n                  buffers which can be used to push commands to the RPU.\n\n Hostport queue information passed by the RPU to the host, which the host can\n use, to communicate with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_hpqm_info {
    pub event_busy_queue: host_rpu_hpq,
    pub event_avl_queue: host_rpu_hpq,
    pub cmd_busy_queue: host_rpu_hpq,
    pub cmd_avl_queue: host_rpu_hpq,
    pub rx_buf_busy_queue: [host_rpu_hpq; 3usize],
}
#[doc = " struct host_rpu_msg_hdr - Common header included in each command/event.\n @len: Length of the message.\n @resubmit: Flag to indicate whether the recipient is expected to resubmit\n            the cmd/event address back to the trasmitting entity.\n\n This structure encapsulates the common information included at the start of\n each command/event exchanged with the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_msg_hdr {
    pub len: ::core::ffi::c_uint,
    pub resubmit: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pta_ext_params {
    #[doc = " Set polarity to 1 if  BT_TX_RX active high indicates Tx. Set polarity to 0 if BT_TX_RX\n active high indicates Rx."]
    pub tx_rx_pol: ::core::ffi::c_uchar,
    #[doc = " BT_ACTIVE signal lead time period. This is with reference to time instance at which\nBT slot boundary starts if BT supports classic only mode and BT activity starts if BT\nsupports BLE or dual mode"]
    pub lead_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which BT_STATUS is sampled by PTA to get the BT_PTI information. This\nis done anywhere between BT_ACTIVE_ASSERT time and BT_STATUS priority signalling time\nperiod ends.This is with reference to BT_ACTIVE assert time."]
    pub pti_samp_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which BT_STATUS is sampled by PTA to get BT_TX_RX information.\nThis is done by PTA after the end of time period T2.  This is with reference to BT_ACTIVE\nassert time."]
    pub tx_rx_samp_time: ::core::ffi::c_uint,
    #[doc = " Time instance at which PTA takes arbitration decision and posts WLAN_DENY to BT. This\n is with reference to BT_ACTIVE assert time."]
    pub dec_time: ::core::ffi::c_uint,
}
#[repr(u32)]
#[doc = " enum host_rpu_msg_type - RPU message type\n @HOST_RPU_MSG_TYPE_SYSTEM: Unused\n @HOST_RPU_MSG_TYPE_SUPPLICANT: Unused\n @HOST_RPU_MSG_TYPE_DATA: Data path and System messages\n @HOST_RPU_MSG_TYPE_UMAC: Control path messages\n\n Different categories of messages that can passed between the Host and\n the RPU."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum host_rpu_msg_type {
    HOST_RPU_MSG_TYPE_SYSTEM = 0,
    HOST_RPU_MSG_TYPE_SUPPLICANT = 1,
    HOST_RPU_MSG_TYPE_DATA = 2,
    HOST_RPU_MSG_TYPE_UMAC = 3,
}
#[doc = " struct host_rpu_msg - Message header for HOST-RPU interaction\n @hdr: Message header\n @type: Type of the RPU message\n @msg: Actual message\n\n The common message header that encapsulates each message passed between the\n Host and UMAC."]
#[repr(C, packed)]
pub struct host_rpu_msg {
    pub hdr: host_rpu_msg_hdr,
    pub type_: ::core::ffi::c_int,
    pub msg: __IncompleteArrayField<::core::ffi::c_schar>,
}
#[doc = " struct sta_pend_frames_bitmap - STA pending frames bitmap in SoftAP power save mode.\n @mac_addr: STA MAC address\n @pend_frames_bitmap: Pending frames bitmap for each access category"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sap_pend_frames_bitmap {
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub pend_frames_bitmap: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct host_rpu_umac_info {
    pub boot_status: ::core::ffi::c_uint,
    pub version: ::core::ffi::c_uint,
    pub sap_bitmap: [sap_pend_frames_bitmap; 4usize],
    pub hpqm_info: host_rpu_hpqm_info,
    pub info_part: ::core::ffi::c_uint,
    pub info_variant: ::core::ffi::c_uint,
    pub info_lromversion: ::core::ffi::c_uint,
    pub info_uromversion: ::core::ffi::c_uint,
    pub info_uuid: [::core::ffi::c_uint; 4usize],
    pub info_spare0: ::core::ffi::c_uint,
    pub info_spare1: ::core::ffi::c_uint,
    pub mac_address0: [::core::ffi::c_uint; 2usize],
    pub mac_address1: [::core::ffi::c_uint; 2usize],
    pub calib: [::core::ffi::c_uint; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_prod_stats {
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    pub unable_gen_event: ::core::ffi::c_uint,
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    pub channel_prog_done: ::core::ffi::c_uint,
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    pub ack_resp_cnt: ::core::ffi::c_uint,
    pub tx_timeout: ::core::ffi::c_uint,
    pub deagg_isr: ::core::ffi::c_uint,
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    pub rx_decryptcnt: ::core::ffi::c_uint,
    pub process_decrypt_fail: ::core::ffi::c_uint,
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    pub rx_event_buf_full: ::core::ffi::c_uint,
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    pub scan_req: ::core::ffi::c_uint,
    pub scan_complete: ::core::ffi::c_uint,
    pub scan_abort_req: ::core::ffi::c_uint,
    pub scan_abort_complete: ::core::ffi::c_uint,
    pub internal_buf_pool_null: ::core::ffi::c_uint,
}
#[doc = " struct phy_prod_stats : used to get the production mode stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct phy_prod_stats {
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
    pub averageRSSI: ::core::ffi::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rpu_stats {
    pub lmac_stats: lmac_prod_stats,
    pub phy_stats: phy_prod_stats,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct hpqm_queue {
    pub pop_addr: ::core::ffi::c_uint,
    pub push_addr: ::core::ffi::c_uint,
    pub id_num: ::core::ffi::c_uint,
    pub status_addr: ::core::ffi::c_uint,
    pub status_mask: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct INT_HPQ {
    pub id: ::core::ffi::c_uint,
    pub head: ::core::ffi::c_uint,
    pub tail: ::core::ffi::c_uint,
}
#[doc = " struct lmac_fw_config_params:lmac firmware config params\n @boot_status:\t\tlmac firmware boot status. LMAC will set to\n\t\t\t\t0x5a5a5a5a after completing boot process.\n @rpu_config_name:\t\trpu config name. this is a string and\n\t\t\t\texpected sting is explorer or whisper\n @rpu_config_number:\t\trpu config number\n @HP_lmac_to_host_isr_en:\tlmac register address to enable ISR to Host\n @HP_lmac_to_host_isr_clear:\tAddress to Clear host ISR\n @HP_set_lmac_isr:\t\tAddress to set ISR to lmac Clear host ISR\n @FreeCmdPtrQ:\t\tqueue which contains Free GRAM pointers for\n\t\t\t\tcommands.\n @cmdPtrQ:\t\t\tCommand pointer queue. Host should pick gram\n\t\t\t\tpointer from FreeCmdPtrQ. Populate command in\n\t\t\t\tGRAM and submit back to this queue for RPU.\n @eventPtrQ:\t\t\tEvent pointer queue. Host should pick gram\n\t\t\t\tevent pointer in isr\n @version:\t\t\tlmac firmware version\n\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct lmac_fw_config_params {
    pub boot_status: ::core::ffi::c_uint,
    pub version: ::core::ffi::c_uint,
    pub lmac_rx_buffer_addr: ::core::ffi::c_uint,
    pub lmac_rx_max_desc_cnt: ::core::ffi::c_uint,
    pub lmac_rx_desc_size: ::core::ffi::c_uint,
    pub rpu_config_name: [::core::ffi::c_uchar; 16usize],
    pub rpu_config_number: [::core::ffi::c_uchar; 8usize],
    pub numRX: ::core::ffi::c_uint,
    pub numTX: ::core::ffi::c_uint,
    pub bands: ::core::ffi::c_uint,
    pub sys_frequency_in_mhz: ::core::ffi::c_uint,
    pub FreeCmdPtrQ: hpqm_queue,
    pub cmdPtrQ: hpqm_queue,
    pub eventPtrQ: hpqm_queue,
    pub freeEventPtrQ: hpqm_queue,
    pub SKBGramPtrQ_1: hpqm_queue,
    pub SKBGramPtrQ_2: hpqm_queue,
    pub SKBGramPtrQ_3: hpqm_queue,
    pub HP_lmac_to_host_isr_en: ::core::ffi::c_uint,
    pub HP_lmac_to_host_isr_clear: ::core::ffi::c_uint,
    pub HP_set_lmac_isr: ::core::ffi::c_uint,
    pub hpq32: [INT_HPQ; 4usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rx_buf_pool_params {
    pub buf_sz: ::core::ffi::c_ushort,
    pub num_bufs: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct temp_vbat_config {
    pub temp_based_calib_en: ::core::ffi::c_uint,
    pub temp_calib_bitmap: ::core::ffi::c_uint,
    pub vbat_calibp_bitmap: ::core::ffi::c_uint,
    pub temp_vbat_mon_period: ::core::ffi::c_uint,
    pub vth_very_low: ::core::ffi::c_int,
    pub vth_low: ::core::ffi::c_int,
    pub vth_hi: ::core::ffi::c_int,
    pub temp_threshold: ::core::ffi::c_int,
    pub vbat_threshold: ::core::ffi::c_int,
}
impl sys_iftype {
    pub const UMAC_IFTYPE_MAX: sys_iftype = sys_iftype::UMAC_IFTYPE_OCB;
}
#[repr(u32)]
#[doc = " enum sys_iftype - Interface types based on functionality.\n\n @UMAC_IFTYPE_UNSPECIFIED: Unspecified type, driver decides.\n @UMAC_IFTYPE_ADHOC: Independent BSS member.\n @UMAC_IFTYPE_STATION: Managed BSS member.\n @UMAC_IFTYPE_AP: Access point.\n @UMAC_IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces\n\tare a bit special in that they must always be tied to a pre-existing\n\tAP type interface.\n @UMAC_IFTYPE_WDS: Wireless Distribution System.\n @UMAC_IFTYPE_MONITOR: Monitor interface receiving all frames.\n @UMAC_IFTYPE_MESH_POINT: Mesh point.\n @UMAC_IFTYPE_P2P_CLIENT: P2P client.\n @UMAC_IFTYPE_P2P_GO: P2P group owner.\n @UMAC_IFTYPE_P2P_DEVICE: P2P device interface type, this is not a netdev\n\tand therefore can't be created in the normal ways, use the\n\t%UMAC_CMD_START_P2P_DEVICE and %UMAC_CMD_STOP_P2P_DEVICE\n\tcommands (Refer &enum umac_commands) to create and destroy one.\n @UMAC_IFTYPE_OCB: Outside Context of a BSS.\n\tThis mode corresponds to the MIB variable dot11OCBActivated=true.\n @UMAC_IFTYPE_MAX: Highest interface type number currently defined.\n @UMAC_IFTYPES: Number of defined interface types.\n\n Lists the different interface types based on how they are configured\n functionally."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sys_iftype {
    UMAC_IFTYPE_UNSPECIFIED = 0,
    UMAC_IFTYPE_ADHOC = 1,
    UMAC_IFTYPE_STATION = 2,
    UMAC_IFTYPE_AP = 3,
    UMAC_IFTYPE_AP_VLAN = 4,
    UMAC_IFTYPE_WDS = 5,
    UMAC_IFTYPE_MONITOR = 6,
    UMAC_IFTYPE_MESH_POINT = 7,
    UMAC_IFTYPE_P2P_CLIENT = 8,
    UMAC_IFTYPE_P2P_GO = 9,
    UMAC_IFTYPE_P2P_DEVICE = 10,
    UMAC_IFTYPE_OCB = 11,
    UMAC_IFTYPES = 12,
}
#[repr(u32)]
#[doc = " enum rpu_op_mode - operating modes.\n\n @RPU_OP_MODE_NORMAL: Normal mode is the regular mode of operation\n @RPU_OP_MODE_DBG: Debug mode can be used to control certain parameters\n\tlike TX rate etc in order to debug functional issues\n @RPU_OP_MODE_PROD: Production mode is used for performing production\n\ttests using continuous Tx/Rx on a configured channel at a particular\n\trate, power etc\n @RPU_OP_MODE_FCM: In the FCM mode different type of calibration like RF\n\tcalibration can be performed\n\n Lists the different types of operating modes."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_op_mode {
    RPU_OP_MODE_RADIO_TEST = 0,
    RPU_OP_MODE_FCM = 1,
    RPU_OP_MODE_REG = 2,
    RPU_OP_MODE_DBG = 3,
    RPU_OP_MODE_MAX = 4,
}
#[repr(u32)]
#[doc = " enum rpu_stats_type - statistics type.\n\n To obtain statistics relevant to the operation mode set via op_mode\n parameter."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_stats_type {
    RPU_STATS_TYPE_ALL = 0,
    RPU_STATS_TYPE_HOST = 1,
    RPU_STATS_TYPE_UMAC = 2,
    RPU_STATS_TYPE_LMAC = 3,
    RPU_STATS_TYPE_PHY = 4,
    RPU_STATS_TYPE_MAX = 5,
}
#[repr(u32)]
#[doc = " enum rpu_tput_mode - Throughput mode\n\n Throughput mode to be used for transmitting the packet."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_tput_mode {
    RPU_TPUT_MODE_LEGACY = 0,
    RPU_TPUT_MODE_HT = 1,
    RPU_TPUT_MODE_VHT = 2,
    RPU_TPUT_MODE_HE_SU = 3,
    RPU_TPUT_MODE_HE_ER_SU = 4,
    RPU_TPUT_MODE_HE_TB = 5,
    RPU_TPUT_MODE_MAX = 6,
}
#[repr(u32)]
#[doc = " enum sys_commands - system commands\n @CMD_INIT: After host driver bringup host sends the CMD_INIT\n\tto the RPU. then RPU initializes and responds with\n\tEVENT_BUFF_CONFIG.\n @CMD_BUFF_CONFIG_COMPLETE: Host sends this command to RPU after\n\tcompletion of all buffers configuration\n @CMD_TX: command to send a Tx packet\n @CMD_MODE: command to specify mode of operation\n @CMD_GET_STATS: command to get statistics\n @CMD_CLEAR_STATS: command to clear statistics\n @CMD_RX: command to ENABLE/DISABLE receiving packets in radio test mode\n @CMD_DEINIT: RPU De-initialization\n @CMD_HE_GI_LTF_CONFIG: Configure HE_GI & HE_LTF.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sys_commands {
    CMD_INIT = 0,
    CMD_TX = 1,
    CMD_IF_TYPE = 2,
    CMD_MODE = 3,
    CMD_GET_STATS = 4,
    CMD_CLEAR_STATS = 5,
    CMD_RX = 6,
    CMD_PWR = 7,
    CMD_DEINIT = 8,
    CMD_BTCOEX = 9,
    CMD_RF_TEST = 10,
    CMD_HE_GI_LTF_CONFIG = 11,
    CMD_UMAC_INT_STATS = 12,
    CMD_RADIO_TEST_INIT = 13,
    CMD_RT_REQ_SET_REG = 14,
    CMD_TX_FIX_DATA_RATE = 15,
}
#[repr(u32)]
#[doc = " enum sys_events -\n @EVENT_BUFF_CONFIG: Response to CMD_INIT\n\tsee &struct event_buffs_config\n @EVENT_BUFF_CONFIG_DONE: Response to CMD_BUFF_CONFIG_COMPLETE\n @EVENT_STATS: Response to CMD_GET_STATS\n @EVENT_DEINIT_DONE: Response to CMD_DEINIT\n\n Events from the RPU for different commands."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum sys_events {
    EVENT_PWR_DATA = 0,
    EVENT_INIT_DONE = 1,
    EVENT_STATS = 2,
    EVENT_DEINIT_DONE = 3,
    EVENT_RF_TEST = 4,
    EVENT_COEX_CONFIG = 5,
    EVENT_INT_UMAC_STATS = 6,
    EVENT_RADIOCMD_STATUS = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_ch_bw {
    RPU_CH_BW_20 = 0,
    RPU_CH_BW_40 = 1,
    RPU_CH_BW_MAX = 2,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct chan_params {
    pub primary_num: ::core::ffi::c_uint,
    pub bw: ::core::ffi::c_uchar,
    pub sec_20_offset: ::core::ffi::c_int,
    pub sec_40_offset: ::core::ffi::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_rx_radio_test_params {
    pub nss: ::core::ffi::c_uchar,
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    pub chan: chan_params,
    pub phy_threshold: ::core::ffi::c_schar,
    pub phy_calib: ::core::ffi::c_uint,
    pub rx: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_rx_dbg_params {
    pub lmac_events: ::core::ffi::c_uint,
    pub rx_events: ::core::ffi::c_uint,
    pub rx_coalesce_events: ::core::ffi::c_uint,
    pub total_rx_pkts_from_lmac: ::core::ffi::c_uint,
    pub max_refill_gap: ::core::ffi::c_uint,
    pub current_refill_gap: ::core::ffi::c_uint,
    pub out_of_order_mpdus: ::core::ffi::c_uint,
    pub reorder_free_mpdus: ::core::ffi::c_uint,
    pub umac_consumed_pkts: ::core::ffi::c_uint,
    pub host_consumed_pkts: ::core::ffi::c_uint,
    pub rx_mbox_post: ::core::ffi::c_uint,
    pub rx_mbox_receive: ::core::ffi::c_uint,
    pub reordering_ampdu: ::core::ffi::c_uint,
    pub timer_mbox_post: ::core::ffi::c_uint,
    pub timer_mbox_rcv: ::core::ffi::c_uint,
    pub work_mbox_post: ::core::ffi::c_uint,
    pub work_mbox_rcv: ::core::ffi::c_uint,
    pub tasklet_mbox_post: ::core::ffi::c_uint,
    pub tasklet_mbox_rcv: ::core::ffi::c_uint,
    pub userspace_offload_frames: ::core::ffi::c_uint,
    pub alloc_buf_fail: ::core::ffi::c_uint,
    pub rx_packet_total_count: ::core::ffi::c_uint,
    pub rx_packet_data_count: ::core::ffi::c_uint,
    pub rx_packet_qos_data_count: ::core::ffi::c_uint,
    pub rx_packet_protected_data_count: ::core::ffi::c_uint,
    pub rx_packet_mgmt_count: ::core::ffi::c_uint,
    pub rx_packet_beacon_count: ::core::ffi::c_uint,
    pub rx_packet_probe_resp_count: ::core::ffi::c_uint,
    pub rx_packet_auth_count: ::core::ffi::c_uint,
    pub rx_packet_deauth_count: ::core::ffi::c_uint,
    pub rx_packet_assoc_resp_count: ::core::ffi::c_uint,
    pub rx_packet_disassoc_count: ::core::ffi::c_uint,
    pub rx_packet_action_count: ::core::ffi::c_uint,
    pub rx_packet_probe_req_count: ::core::ffi::c_uint,
    pub rx_packet_other_mgmt_count: ::core::ffi::c_uint,
    pub max_coalesce_pkts: ::core::ffi::c_schar,
    pub null_skb_pointer_from_lmac: ::core::ffi::c_uint,
    pub unexpected_mgmt_pkt: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_tx_dbg_params {
    pub tx_cmd: ::core::ffi::c_uint,
    pub tx_non_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_max_coalesce_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_cmds_max_used: ::core::ffi::c_uint,
    pub tx_cmds_currently_in_use: ::core::ffi::c_uint,
    pub tx_done_events_send_to_host: ::core::ffi::c_uint,
    pub tx_done_success_pkts_to_host: ::core::ffi::c_uint,
    pub tx_done_failure_pkts_to_host: ::core::ffi::c_uint,
    pub tx_cmds_with_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_cmds_with_non_crypto_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_cmds_with_broadcast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_cmds_with_multicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub tx_cmds_with_unicast_pkts_rcvd_from_host: ::core::ffi::c_uint,
    pub xmit: ::core::ffi::c_uint,
    pub send_addba_req: ::core::ffi::c_uint,
    pub addba_resp: ::core::ffi::c_uint,
    pub softmac_tx: ::core::ffi::c_uint,
    pub internal_pkts: ::core::ffi::c_uint,
    pub external_pkts: ::core::ffi::c_uint,
    pub tx_cmds_to_lmac: ::core::ffi::c_uint,
    pub tx_dones_from_lmac: ::core::ffi::c_uint,
    pub total_cmds_to_lmac: ::core::ffi::c_uint,
    pub tx_packet_data_count: ::core::ffi::c_uint,
    pub tx_packet_mgmt_count: ::core::ffi::c_uint,
    pub tx_packet_beacon_count: ::core::ffi::c_uint,
    pub tx_packet_probe_req_count: ::core::ffi::c_uint,
    pub tx_packet_auth_count: ::core::ffi::c_uint,
    pub tx_packet_deauth_count: ::core::ffi::c_uint,
    pub tx_packet_assoc_req_count: ::core::ffi::c_uint,
    pub tx_packet_disassoc_count: ::core::ffi::c_uint,
    pub tx_packet_action_count: ::core::ffi::c_uint,
    pub tx_packet_other_mgmt_count: ::core::ffi::c_uint,
    pub tx_packet_non_mgmt_data_count: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_evnt_dbg_params {
    pub cmd_init: ::core::ffi::c_uchar,
    pub event_init_done: ::core::ffi::c_uchar,
    pub cmd_rf_test: ::core::ffi::c_uchar,
    pub cmd_connect: ::core::ffi::c_uchar,
    pub cmd_get_stats: ::core::ffi::c_uint,
    pub event_ps_state: ::core::ffi::c_uint,
    pub cmd_set_reg: ::core::ffi::c_uint,
    pub cmd_get_reg: ::core::ffi::c_uint,
    pub cmd_req_set_reg: ::core::ffi::c_uint,
    pub cmd_trigger_scan: ::core::ffi::c_uint,
    pub event_scan_done: ::core::ffi::c_uint,
    pub cmd_get_scan: ::core::ffi::c_uint,
    pub umac_scan_req: ::core::ffi::c_uint,
    pub umac_scan_complete: ::core::ffi::c_uint,
    pub umac_scan_busy: ::core::ffi::c_uint,
    pub cmd_auth: ::core::ffi::c_uint,
    pub cmd_assoc: ::core::ffi::c_uint,
    pub cmd_deauth: ::core::ffi::c_uint,
    pub cmd_register_frame: ::core::ffi::c_uint,
    pub cmd_frame: ::core::ffi::c_uint,
    pub cmd_del_key: ::core::ffi::c_uint,
    pub cmd_new_key: ::core::ffi::c_uint,
    pub cmd_set_key: ::core::ffi::c_uint,
    pub cmd_get_key: ::core::ffi::c_uint,
    pub event_beacon_hint: ::core::ffi::c_uint,
    pub event_reg_change: ::core::ffi::c_uint,
    pub event_wiphy_reg_change: ::core::ffi::c_uint,
    pub cmd_set_station: ::core::ffi::c_uint,
    pub cmd_new_station: ::core::ffi::c_uint,
    pub cmd_del_station: ::core::ffi::c_uint,
    pub cmd_new_interface: ::core::ffi::c_uint,
    pub cmd_set_interface: ::core::ffi::c_uint,
    pub cmd_get_interface: ::core::ffi::c_uint,
    pub cmd_set_ifflags: ::core::ffi::c_uint,
    pub cmd_set_ifflags_done: ::core::ffi::c_uint,
    pub cmd_set_bss: ::core::ffi::c_uint,
    pub cmd_set_wiphy: ::core::ffi::c_uint,
    pub cmd_start_ap: ::core::ffi::c_uint,
    pub LMAC_CMD_PS: ::core::ffi::c_uint,
    pub CURR_STATE: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct interface_stats {
    pub tx_unicast_pkt_count: ::core::ffi::c_uint,
    pub tx_multicast_pkt_count: ::core::ffi::c_uint,
    pub tx_broadcast_pkt_count: ::core::ffi::c_uint,
    pub tx_bytes: ::core::ffi::c_uint,
    pub rx_unicast_pkt_count: ::core::ffi::c_uint,
    pub rx_multicast_pkt_count: ::core::ffi::c_uint,
    pub rx_broadcast_pkt_count: ::core::ffi::c_uint,
    pub rx_beacon_success_count: ::core::ffi::c_uint,
    pub rx_beacon_miss_count: ::core::ffi::c_uint,
    pub rx_bytes: ::core::ffi::c_uint,
    pub rx_checksum_error_count: ::core::ffi::c_uint,
    pub replay_attack_drop_cnt: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_umac_stats {
    pub tx_dbg_params: umac_tx_dbg_params,
    pub rx_dbg_params: umac_rx_dbg_params,
    pub cmd_evnt_dbg_params: umac_cmd_evnt_dbg_params,
    pub interface_data_stats: interface_stats,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_lmac_stats {
    pub reset_cmd_cnt: ::core::ffi::c_uint,
    pub reset_complete_event_cnt: ::core::ffi::c_uint,
    pub unable_gen_event: ::core::ffi::c_uint,
    pub ch_prog_cmd_cnt: ::core::ffi::c_uint,
    pub channel_prog_done: ::core::ffi::c_uint,
    pub tx_pkt_cnt: ::core::ffi::c_uint,
    pub tx_pkt_done_cnt: ::core::ffi::c_uint,
    pub scan_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_cnt: ::core::ffi::c_uint,
    pub internal_pkt_done_cnt: ::core::ffi::c_uint,
    pub ack_resp_cnt: ::core::ffi::c_uint,
    pub tx_timeout: ::core::ffi::c_uint,
    pub deagg_isr: ::core::ffi::c_uint,
    pub deagg_inptr_desc_empty: ::core::ffi::c_uint,
    pub deagg_circular_buffer_full: ::core::ffi::c_uint,
    pub lmac_rxisr_cnt: ::core::ffi::c_uint,
    pub rx_decryptcnt: ::core::ffi::c_uint,
    pub process_decrypt_fail: ::core::ffi::c_uint,
    pub prepa_rx_event_fail: ::core::ffi::c_uint,
    pub rx_core_pool_full_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_mpdu_crc_fail_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_success_cnt: ::core::ffi::c_uint,
    pub rx_ofdm_crc_fail_cnt: ::core::ffi::c_uint,
    pub rxDSSSCrcSuccessCnt: ::core::ffi::c_uint,
    pub rxDSSSCrcFailCnt: ::core::ffi::c_uint,
    pub rx_crypto_start_cnt: ::core::ffi::c_uint,
    pub rx_crypto_done_cnt: ::core::ffi::c_uint,
    pub rx_event_buf_full: ::core::ffi::c_uint,
    pub rx_extram_buf_full: ::core::ffi::c_uint,
    pub scan_req: ::core::ffi::c_uint,
    pub scan_complete: ::core::ffi::c_uint,
    pub scan_abort_req: ::core::ffi::c_uint,
    pub scan_abort_complete: ::core::ffi::c_uint,
    pub internal_buf_pool_null: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_phy_stats {
    pub rssi_avg: ::core::ffi::c_schar,
    pub pdout_val: ::core::ffi::c_uchar,
    pub ofdm_crc32_pass_cnt: ::core::ffi::c_uint,
    pub ofdm_crc32_fail_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_pass_cnt: ::core::ffi::c_uint,
    pub dsss_crc32_fail_cnt: ::core::ffi::c_uint,
}
#[doc = " struct sys_head - Command/Event header.\n @cmd: Command/Event id.\n @len: Payload length.\n\n This header needs to be initialized in every command and has the event\n id info in case of events."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sys_head {
    pub cmd_event: ::core::ffi::c_uint,
    pub len: ::core::ffi::c_uint,
}
#[doc = " struct bgscan_params - Background Scan parameters.\n @enabled: Enable/Disable background scan.\n @channel_list: List of channels to scan.\n @channel_flags: Channel flags for each of the channels which are to be\n\tscanned.\n @scan_intval: Back ground scan is done at regular intervals. This\n\tvalue is set to the interval value (in ms).\n @channel_dur: Time to be spent on each channel (in ms).\n @serv_channel_dur: In \"Connected State\" scanning, we need to share the time\n\tbetween operating channel and non-operating channels.\n\tAfter scanning each channel, the firmware spends\n\t\"serv_channel_dur\" (in ms) on the operating channel.\n @num_channels: Number of channels to be scanned.\n\n This structure specifies the parameters which will be used during a\n Background Scan."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct bgscan_params {
    pub enabled: ::core::ffi::c_uint,
    pub channel_list: [::core::ffi::c_uchar; 50usize],
    pub channel_flags: [::core::ffi::c_uchar; 50usize],
    pub scan_intval: ::core::ffi::c_uint,
    pub channel_dur: ::core::ffi::c_uint,
    pub serv_channel_dur: ::core::ffi::c_uint,
    pub num_channels: ::core::ffi::c_uint,
}
#[repr(u32)]
#[doc = " enum max_rx_ampdu_size - Max Rx AMPDU size in KB\n\n Max Rx AMPDU Size"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum max_rx_ampdu_size {
    MAX_RX_AMPDU_SIZE_8KB = 0,
    MAX_RX_AMPDU_SIZE_16KB = 1,
    MAX_RX_AMPDU_SIZE_32KB = 2,
    MAX_RX_AMPDU_SIZE_64KB = 3,
}
#[doc = " struct data_config_params - Data config parameters\n @rate_protection_type:0->NONE, 1->RTS/CTS, 2->CTS2SELF\n @aggregation: Agreegation is enabled(FEATURE_ENABLE) or disabled\n\t\t(FEATURE_DISABLE)\n @wmm: WMM is enabled(FEATURE_ENABLE) or disabled\n\t\t(FEATURE_DISABLE)\n @max_num_tx_agg_sessions: Max number of aggregated TX sessions\n @max_num_rx_agg_sessions: Max number of aggregated RX sessions\n @reorder_buf_size: Reorder buffer size (1 to 64)\n @max_rxampdu_size: Max RX AMPDU size (8/16/32/64 KB), see\n\t\t\t\t\tenum max_rx_ampdu_size\n\n Data configuration parameters provided in command CMD_INIT"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct data_config_params {
    pub rate_protection_type: ::core::ffi::c_uchar,
    pub aggregation: ::core::ffi::c_uchar,
    pub wmm: ::core::ffi::c_uchar,
    pub max_num_tx_agg_sessions: ::core::ffi::c_uchar,
    pub max_num_rx_agg_sessions: ::core::ffi::c_uchar,
    pub max_tx_aggregation: ::core::ffi::c_uchar,
    pub reorder_buf_size: ::core::ffi::c_uchar,
    pub max_rxampdu_size: ::core::ffi::c_int,
}
#[doc = " struct sys_params - Init parameters during CMD_INIT\n @mac_addr: MAC address of the interface\n @sleep_enable: enable rpu sleep\n @hw_bringup_time:\n @sw_bringup_time:\n @bcn_time_out:\n @calib_sleep_clk:\n @rf_params: RF parameters\n @rf_params_valid: Indicates whether the @rf_params has a valid value.\n @phy_calib: PHY calibration parameters\n\n System parameters provided for command CMD_INIT"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sys_params {
    pub sleep_enable: ::core::ffi::c_uint,
    pub hw_bringup_time: ::core::ffi::c_uint,
    pub sw_bringup_time: ::core::ffi::c_uint,
    pub bcn_time_out: ::core::ffi::c_uint,
    pub calib_sleep_clk: ::core::ffi::c_uint,
    pub phy_calib: ::core::ffi::c_uint,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    pub rf_params_valid: ::core::ffi::c_uchar,
}
#[doc = " struct tx_pow_ctrl_params - Parameters which control TX power.\n @ant_gain_2g: Antenna gain for 2.4 GHz band.\n @ant_gain_5g_band1 : Antenna gain for 5 GHz band (5150 MHz - 5350 MHz).\n ant_gain_5g_band2 : Antenna gain for 5 GHz band (5470 MHz - 5730 MHz).\n ant_gain_5g_band3 : Antenna gain for 5 GHz band (5730 MHz - 5895 MHz).\n @band_edge_2g_lo: Transmit power backoff (in dB) for lower edge of 2.4 GHz frequency band.\n @band_edge_2g_hi: Transmit power backoff (in dB) for upper edge of 2.4 GHz frequency band.\n @band_edge_5g_unii_1_lo: Transmit power backoff (in dB) for lower edge of UNII-1 frequency band.\n @band_edge_5g_unii_1_hi: Transmit power backoff (in dB) for upper edge of UNII-1 frequency band.\n @band_edge_5g_unii_2a_lo: Transmit power backoff (in dB) for lower edge of UNII-2A frequency band\n @band_edge_5g_unii_2a_hi: Transmit power backoff (in dB) for upper edge of UNII-2A frequency band\n @band_edge_5g_unii_2c_lo: Transmit power backoff (in dB) for lower edge of UNII-2C frequency band\n @band_edge_5g_unii_2c_hi: Transmit power backoff (in dB) for upper edge of UNII-2C frequency band\n @band_edge_5g_unii_3_lo: Transmit power backoff (in dB) for lower edge of UNII-3 frequency band.\n @band_edge_5g_unii_3_hi: Transmit power backoff (in dB) for upper edge of UNII-3 frequency band.\n @band_edge_5g_unii_4_lo: Transmit power backoff (in dB) for lower edge of UNII-4 frequency band.\n @band_edge_5g_unii_4_hi: Transmit power backoff (in dB) for upper edge of UNII-4 frequency band.\n\n System parameters provided for controlling TX power."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_pwr_ctrl_params {
    pub ant_gain_2g: ::core::ffi::c_uchar,
    pub ant_gain_5g_band1: ::core::ffi::c_uchar,
    pub ant_gain_5g_band2: ::core::ffi::c_uchar,
    pub ant_gain_5g_band3: ::core::ffi::c_uchar,
    pub band_edge_2g_lo: ::core::ffi::c_uchar,
    pub band_edge_2g_hi: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_1_lo: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_1_hi: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_2a_lo: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_2a_hi: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_2c_lo: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_2c_hi: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_3_lo: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_3_hi: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_4_lo: ::core::ffi::c_uchar,
    pub band_edge_5g_unii_4_hi: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum op_band {
    BAND_ALL = 0,
    BAND_24G = 1,
}
#[doc = " struct cmd_sys_init - Initialize UMAC\n @sys_head: umac header, see &sys_head\n @wdev_id : id of the interface.\n @sys_params: iftype, mac address, see sys_params\n @rx_buf_pools: LMAC Rx buffs pool params, see struct rx_buf_pool_params\n @data_config_params: Data configuration params, see struct data_config_params\n @tcp_ip_checksum_offload: 0:umac checksum disable 1: umac checksum enable\n @op_band: operating band see enum op_band\n @mgmt_buff_offload: Target selection for management buffers deallocation 0:HOST 1:UMAC.\n After host driver bringup host sends the CMD_INIT to the RPU.\n then RPU initializes and responds with EVENT_BUFF_CONFIG."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_sys_init {
    pub sys_head: sys_head,
    pub wdev_id: ::core::ffi::c_uint,
    pub sys_params: sys_params,
    pub rx_buf_pools: [rx_buf_pool_params; 3usize],
    pub data_config_params: data_config_params,
    pub temp_vbat_config_params: temp_vbat_config,
    pub tcp_ip_checksum_offload: ::core::ffi::c_uchar,
    pub country_code: [::core::ffi::c_uchar; 2usize],
    pub op_band: ::core::ffi::c_uint,
    pub tx_pwr_ctrl_params: tx_pwr_ctrl_params,
    pub mgmt_buff_offload: ::core::ffi::c_uchar,
}
#[doc = " struct cmd_sys_deinit - De-initialize UMAC\n @sys_head: umac header, see &sys_head\n\n De-initializes the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_sys_deinit {
    pub sys_head: sys_head,
}
#[doc = " struct cmd_he_gi_ltf_config - Confure HE-GI and HE-LTF.\n @sys_head: umac header, see &sys_head\n @wdev_id: wdev interface id.\n @he_gi_type: HE GI type(HE_GI_800NS/HE_GI_1600NS/HE_GI_3200NS).\n @he_ltf: HE LTF(HE_LTF_3200NS/HE_LTF_6400NS/HE_LTF_12800NS).\n @enable: Fixed HE GI & LTF values can be enabled and disabled\n Host configures the HE-GI & HE-LTF for testing purpose\n need to use this values in Tx command sending to LMAC."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_he_gi_ltf_config {
    pub sys_head: sys_head,
    pub wdev_id: ::core::ffi::c_uchar,
    pub he_gi_type: ::core::ffi::c_uchar,
    pub he_ltf: ::core::ffi::c_uchar,
    pub enable: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_buff_config_complete {
    pub sys_head: sys_head,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rpu_pkt_preamble {
    RPU_PKT_PREAMBLE_SHORT = 0,
    RPU_PKT_PREAMBLE_LONG = 1,
    RPU_PKT_PREAMBLE_MIXED = 2,
    RPU_PKT_PREAMBLE_MAX = 3,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_mode {
    pub sys_head: sys_head,
    pub mode: ::core::ffi::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_conf_params {
    pub nss: ::core::ffi::c_uchar,
    pub antenna_sel: ::core::ffi::c_uchar,
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    pub tx_pkt_chnl_bw: ::core::ffi::c_uchar,
    pub tx_pkt_tput_mode: ::core::ffi::c_uchar,
    pub tx_pkt_sgi: ::core::ffi::c_uchar,
    pub tx_pkt_nss: ::core::ffi::c_uchar,
    pub tx_pkt_preamble: ::core::ffi::c_uchar,
    pub tx_pkt_stbc: ::core::ffi::c_uchar,
    pub tx_pkt_fec_coding: ::core::ffi::c_uchar,
    pub tx_pkt_mcs: ::core::ffi::c_schar,
    pub tx_pkt_rate: ::core::ffi::c_schar,
    pub phy_threshold: ::core::ffi::c_schar,
    pub phy_calib: ::core::ffi::c_uint,
    pub op_mode: ::core::ffi::c_int,
    pub chan: chan_params,
    pub tx_mode: ::core::ffi::c_uchar,
    pub tx_pkt_num: ::core::ffi::c_int,
    pub tx_pkt_len: ::core::ffi::c_ushort,
    pub tx_power: ::core::ffi::c_uint,
    pub tx: ::core::ffi::c_uchar,
    pub rx: ::core::ffi::c_uchar,
    pub aux_adc_input_chain_id: ::core::ffi::c_uchar,
    pub agg: ::core::ffi::c_uchar,
    pub he_ltf: ::core::ffi::c_uchar,
    pub he_gi: ::core::ffi::c_uchar,
    pub set_he_ltf_gi: ::core::ffi::c_uchar,
    pub power_save: ::core::ffi::c_uchar,
    pub rts_threshold: ::core::ffi::c_uint,
    pub uapsd_queue: ::core::ffi::c_uint,
    pub tx_pkt_gap_us: ::core::ffi::c_uint,
    pub wlan_ant_switch_ctrl: ::core::ffi::c_uchar,
    pub ble_ant_switch_ctrl: ::core::ffi::c_uchar,
    pub ru_tone: ::core::ffi::c_uchar,
    pub ru_index: ::core::ffi::c_uchar,
    pub tx_tone_freq: ::core::ffi::c_schar,
    pub lna_gain: ::core::ffi::c_uchar,
    pub bb_gain: ::core::ffi::c_uchar,
    pub capture_length: ::core::ffi::c_ushort,
    pub bypass_regulatory: ::core::ffi::c_uchar,
    pub country_code: [::core::ffi::c_uchar; 2usize],
    pub tx_pkt_cw: ::core::ffi::c_uint,
}
#[doc = " struct cmd_mode_params\n @sys_head: UMAC header, See &struct sys_head\n @conf: configuration parameters of different modes see &union rpu_conf_params\n\n configures the RPU with config parameters provided in this command"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_mode_params {
    pub sys_head: sys_head,
    pub conf: rpu_conf_params,
    pub pkt_length: [::core::ffi::c_ushort; 16usize],
    pub ddr_ptrs: [::core::ffi::c_uint; 16usize],
}
#[doc = " struct cmd_radio_test_init - command radio_test_init\n @sys_head: UMAC header, See &struct sys_head\n @conf: radiotest init configuration parameters\n see &struct radio_test_init_info\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct radio_test_init_info {
    pub rf_params: [::core::ffi::c_uchar; 200usize],
    pub chan: chan_params,
    pub phy_threshold: ::core::ffi::c_schar,
    pub phy_calib: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_radio_test_init {
    pub sys_head: sys_head,
    pub conf: radio_test_init_info,
}
#[doc = " struct cmd_rx - command rx\n @sys_head: UMAC header, See &struct sys_head\n @conf: rx configuration parameters see &struct rpu_conf_rx_radio_test_params\n @:rx_enable: 1-Enable Rx to receive packets contineously on specified channel\n\t0-Disable Rx stop receiving packets and clear statistics\n\n Command RPU to Enable/Disable Rx"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_rx {
    pub sys_head: sys_head,
    pub conf: rpu_conf_rx_radio_test_params,
}
#[doc = " struct cmd_get_stats - Get statistics\n @sys_head: UMAC header, See &struct sys_head\n @stats_type: Statistics type see &enum rpu_stats_type\n @op_mode: Production mode or FCM mode\n\n This command is to Request the statistics corresponding to stats_type\n selected\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_get_stats {
    pub sys_head: sys_head,
    pub stats_type: ::core::ffi::c_int,
    pub op_mode: ::core::ffi::c_int,
}
#[doc = " struct cmd_clear_stats - clear statistics\n @sys_head: UMAC header, See &struct sys_head.\n @stats_type: Type of statistics to clear see &enum rpu_stats_type\n\n This command is to clear the statistics corresponding to stats_type selected"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_clear_stats {
    pub sys_head: sys_head,
    pub stats_type: ::core::ffi::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_pwr {
    pub sys_head: sys_head,
    pub data_type: ::core::ffi::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct coex_wlan_switch_ctrl {
    pub rpu_msg_id: ::core::ffi::c_int,
    pub switch_A: ::core::ffi::c_int,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_btcoex {
    pub sys_head: sys_head,
    pub conf: coex_wlan_switch_ctrl,
}
#[repr(C, packed)]
pub struct rpu_cmd_coex_config_info {
    pub len: ::core::ffi::c_uint,
    pub coex_cmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
pub struct cmd_coex_config {
    pub sys_head: sys_head,
    pub coex_config_info: rpu_cmd_coex_config_info,
}
#[repr(C, packed)]
pub struct rpu_evnt_coex_config_info {
    pub len: ::core::ffi::c_uint,
    pub coex_event: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
pub struct event_coex_config {
    pub sys_head: sys_head,
    pub coex_config_info: rpu_evnt_coex_config_info,
}
#[doc = " struct cmd_fix_tx_rate - UMAC deinitialization done\n @sys_head: UMAC header, See &struct sys_head.\n rate_flags: refer &enum rpu_tput_mode.\n fixed_rate: -1 Disable fixed rate and use ratecontrol selected rate.\n             >0 legacy rates: 1,2,55,11,6,9,12,18,24,36,48,54.\n                11N VHT HE  : MCS index 0 to 7."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_fix_tx_rate {
    pub sys_head: sys_head,
    pub rate_flags: ::core::ffi::c_uchar,
    pub fixed_rate: ::core::ffi::c_int,
}
#[repr(C, packed)]
pub struct rpu_cmd_rftest_info {
    pub len: ::core::ffi::c_uint,
    pub rfcmd: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
pub struct cmd_rftest {
    pub sys_head: sys_head,
    pub rf_test_info: rpu_cmd_rftest_info,
}
#[repr(C, packed)]
pub struct rpu_evnt_rftest_info {
    pub len: ::core::ffi::c_uint,
    pub rfevent: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
pub struct event_rftest {
    pub sys_head: sys_head,
    pub rf_test_info: rpu_evnt_rftest_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_pwr_data {
    pub sys_head: sys_head,
    pub mon_status: ::core::ffi::c_int,
    pub data_type: ::core::ffi::c_int,
    pub data: rpu_pwr_data,
}
#[doc = " struct rpu_fw_stats - FW statistics\n @phy:  PHY statistics  see &struct rpu_phy_stats\n @lmac: LMAC statistics see &struct rpu_lmac_stats\n @umac: UMAC statistics see &struct rpu_umac_stats\n\n This structure is a combination of all the statistics that the RPU firmware\n can provide\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rpu_fw_stats {
    pub phy: rpu_phy_stats,
    pub lmac: rpu_lmac_stats,
    pub umac: rpu_umac_stats,
}
#[doc = " struct umac_event_stats - statistics event\n @sys_head: UMAC header, See &struct sys_head.\n @fw: All the statistics that the firmware can provide.\n\n This event is the response to command CMD_GET_STATS.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_stats {
    pub sys_head: sys_head,
    pub fw: rpu_fw_stats,
}
#[repr(u32)]
#[doc = " struct umac_event_cmd_err_status - cmd error indication\n @sys_head: UMAC header, See &struct sys_head.\n @status: status of the command ie Fail(Type of err) or success.\n\n This event is the response to command chanl_prog.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum radio_test_err_status {
    UMAC_CMD_SUCCESS = 1,
    UMAC_INVALID_CHNL = 2,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_err_status {
    pub sys_head: sys_head,
    pub status: ::core::ffi::c_uint,
}
#[doc = " struct event_buff_config_done - Buffers configuration done\n @sys_head: UMAC header, See &struct sys_head.\n @mac_addr: Mac address of the RPU\n\n RPU sends this event in response to CMD_BUFF_CONFIG_COMPLETE informing\n RPU is initialized"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_buff_config_done {
    pub sys_head: sys_head,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct txrx_buffs_config - TX/RX buffers config event.\n @sys_head: UMAC header, See &struct sys_head.\n @max_tx_descs: Max number of tx descriptors.\n @max_2k_rx_descs: Max number of 2k rx descriptors.\n @num_8k_rx_descs: Max number of 2k rx descriptors.\n @num_mgmt_descs: Max number of mgmt buffers.\n\n After initialization RPU sends EVENT_BUFF_CONFIG\n to inform host regarding descriptors.\n 8K buffer are for internal purpose. At initialization time host\n submits the 8K buffer and UMAC uses buffers to configure LMAC\n for receiving AMSDU packets."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_buffs_config {
    pub sys_head: sys_head,
    pub max_tx_descs: ::core::ffi::c_uint,
    pub max_2k_rx_descs: ::core::ffi::c_uint,
    pub num_8k_rx_descs: ::core::ffi::c_uint,
    pub num_mgmt_descs: ::core::ffi::c_uint,
}
#[doc = " struct event_init_done - UMAC initialization done\n @sys_head: UMAC header, See &struct sys_head.\n\n RPU sends this event in response to CMD_INIT indicating that the RPU is\n initialized"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_init_done {
    pub sys_head: sys_head,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct pool_data_to_host {
    pub buffer_size: ::core::ffi::c_uint,
    pub num_pool_items: ::core::ffi::c_uchar,
    pub items_num_max_allocated: ::core::ffi::c_uchar,
    pub items_num_cur_allocated: ::core::ffi::c_uchar,
    pub items_num_total_allocated: ::core::ffi::c_uint,
    pub items_num_not_allocated: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_int_stats {
    pub sys_head: sys_head,
    pub scratch_dynamic_memory_info: [pool_data_to_host; 56usize],
    pub retention_dynamic_memory_info: [pool_data_to_host; 56usize],
}
#[doc = " struct event_deinit_done - UMAC deinitialization done\n @sys_head: UMAC header, See &struct sys_head.\n\n RPU sends this event in response to CMD_DEINIT indicating that the RPU is\n deinitialized"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_deinit_done {
    pub sys_head: sys_head,
}
#[repr(u32)]
#[doc = " enum umac_data_commands - UMAC init and data buffer command/events\n\n @CMD_MGMT_BUFF_CONFIG: Configure MGMT frame buffer.\n\tSee &struct rx_buff_config\n @CMD_TX_BUFF: Transmit data packet.\n\tSee &struct tx_buff\n @CMD_TX_BUFF_DONE: TX done event.\n\tSee &struct tx_buff_done\n @CMD_RX_BUFF: RX data event.\n\tSee &struct rx_buff\n @CMD_CARRIER_ON: STA connection complete event.\n\tSee &struct data_carrier_state\n @CMD_CARRIER_OFF: STA disconnected event.\n\tSee &struct data_carrier_state\n @CMD_PM_MODE: SoftAP client power save event.\n\tSee &struct sap_client_pwrsave\n @CMD_PS_GET_FRAMES: SoftAP client PS get frames event.\n\tSee &struct sap_ps_get_frames\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum umac_data_commands {
    CMD_MGMT_BUFF_CONFIG = 0,
    CMD_TX_BUFF = 1,
    CMD_TX_BUFF_DONE = 2,
    CMD_RX_BUFF = 3,
    CMD_CARRIER_ON = 4,
    CMD_CARRIER_OFF = 5,
    CMD_PM_MODE = 6,
    CMD_PS_GET_FRAMES = 7,
}
#[doc = " struct umac_head - Command/Event header.\n @cmd: Command/Event id.\n @len: Payload length.\n\n This header needs to be initialized in every command and has the event\n id info in case of events."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_head {
    pub cmd: ::core::ffi::c_uint,
    pub len: ::core::ffi::c_uint,
}
#[doc = " struct packet_info - Data packet frame pointers.\n @head: Pointer to the start of headroom.\n @data: Potiner to the start of data/actual frame data.\n @tail: End of frame data.\n @end: End of tailroom.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct packet_info {
    pub head: ::core::ffi::c_uint,
    pub data: ::core::ffi::c_uint,
    pub tail: ::core::ffi::c_uint,
    pub end: ::core::ffi::c_uint,
}
#[doc = " struct mgmt_buff_config - Configure management buffers.\n @umac_head: UMAC cmd header, See &struct umac_hdr.\n @num_mgmt_bufs: Number of Mgmt buffers to be configured.\n @ddr_ptrs: Management DDR buffer pointers.\n\n Management buffers once programmed will be used internally by UMAC."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mgmt_buff_config {
    pub umac_head: umac_head,
    pub num_mgmt_bufs: ::core::ffi::c_uint,
    pub ddr_ptrs: [::core::ffi::c_uint; 16usize],
}
#[repr(u32)]
#[doc = " HEADER_FILL_FLAGS - mac80211 header filled information.\n @FC_POPULATED: Frame Control field is populated by Host Driver.\n @DUR_POPULATED: Duration field is populated by Host Driver.\n @ADDR1_POPULATED: Address 1 field is populated by Host Driver.\n @ADDR2_POPULATED: Address 2 field is populated by Host Driver.\n @ADDR3_POPULATED: Address 3 field is populated by Host Driver.\n @SEQ_CTRL_POPULATED: Sequence Control field is populated by Host Driver.\n @QOS_CTRL_POPULATED: Qos field is populated by Host Driver.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum HEADER_FILL_FLAGS {
    FC_POPULATED = 2,
    DUR_POPULATED = 4,
    ADDR1_POPULATED = 8,
    ADDR2_POPULATED = 16,
    ADDR3_POPULATED = 32,
    SEQ_CTRL_POPULATED = 64,
    QOS_CTRL_POPULATED = 128,
}
#[doc = " struct tx_mac_hdr_info - Tx mac80211 header information.\n @umac_head: UMAC cmd header, See &struct umac_hdr.\n @umac_fill_flags: Flags indicates which of the following fields present.\n @fc: Frame Control.\n @more_data: 0-> No more Data, 1-> More Data\n @dest: Destination Address.\n @src: Source Address.\n @etype: Ethernet type.\n @dscp_or_tos: Type of Service.\n @more_data:more frames queued\n @eosp: End Of Service Period flag(applicable in U-APSD)\n\n Host fills the mac80211 header fields and indicates to UMAC."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_mac_hdr_info {
    pub umac_fill_flags: ::core::ffi::c_int,
    pub fc: ::core::ffi::c_ushort,
    pub dest: [::core::ffi::c_uchar; 6usize],
    pub src: [::core::ffi::c_uchar; 6usize],
    pub etype: ::core::ffi::c_ushort,
    pub dscp_or_tos: ::core::ffi::c_uint,
    pub more_data: ::core::ffi::c_uchar,
    pub eosp: ::core::ffi::c_uchar,
}
#[doc = " struct tx_buff_info - TX data command info.\n @pkt_length: Tx packet length.\n @ddr_ptr: Tx packet data pointer."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_buff_info {
    pub pkt_length: ::core::ffi::c_ushort,
    pub ddr_ptr: ::core::ffi::c_uint,
}
#[doc = " struct tx_buff - Send TX packet.\n @umac_head: UMAC cmd header. See &struct umac_hdr.\n @wdev_id: wdev interface id.\n @tx_desc_num: Descriptor id.\n @mac_hdr_info: Common mac header for all packets to be Txed.\n @pending_buf_size: Pending buffer at host\n @num_tx_pkts: Number of packets.\n @tx_buff_info: See tx_buff_info_t for details, the array size can be maximum\n\tof MAX_TX_AGG_SIZE\n\n Host sends the packet information which needs to transmit by\n using %CMD_TX_BUFF."]
#[repr(C, packed)]
pub struct tx_buff {
    pub umac_head: umac_head,
    pub wdev_id: ::core::ffi::c_uchar,
    pub tx_desc_num: ::core::ffi::c_uchar,
    pub mac_hdr_info: tx_mac_hdr_info,
    pub pending_buf_size: ::core::ffi::c_uint,
    pub num_tx_pkts: ::core::ffi::c_uchar,
    pub tx_buff_info: __IncompleteArrayField<tx_buff_info>,
}
#[doc = " struct tx_buff_done - TX done event.\n @umac_head: UMAC event header. See &struct umac_hdr.\n @tx_desc_num: Descriptor id.\n @num_tx_status_code: Total number of received tx status code, the array size can be maximum\n\tof MAX_TX_AGG_SIZE\n @timestamp_t1: Frame sent time at Phy\n @timestamp_t4: Frame ack received time at Phy\n @tx_status_code: Status of TX packet.\n\n RPU acknowledges the packet transmition by using %CMD_TX_BUFF_DONE."]
#[repr(C, packed)]
pub struct tx_buff_done {
    pub umac_head: umac_head,
    pub tx_desc_num: ::core::ffi::c_uchar,
    pub num_tx_status_code: ::core::ffi::c_uchar,
    pub timestamp_t1: [::core::ffi::c_uchar; 6usize],
    pub timestamp_t4: [::core::ffi::c_uchar; 6usize],
    pub tx_status_code: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(u32)]
#[doc = " enum rx_pkt_type: The Received packet type\n @RX_PKT_DATA: The Rx packet is of type data.\n @RX_PKT_BCN_PRB_RSP: The RX packet is of type beacon or probe response\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum rx_pkt_type {
    RX_PKT_DATA = 0,
    RX_PKT_BCN_PRB_RSP = 1,
}
#[doc = " struct rx_buff_info - RX data event info.\n @descriptor_id: Descriptor id.\n @rx_pkt_len: Rx packet length.\n @timestamp_t2: Frame received time at Phy\n @timestamp_t3: Ack sent time at Phy"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rx_buff_info {
    pub descriptor_id: ::core::ffi::c_ushort,
    pub rx_pkt_len: ::core::ffi::c_ushort,
    pub pkt_type: ::core::ffi::c_uchar,
    pub timestamp_t2: [::core::ffi::c_uchar; 6usize],
    pub timestamp_t3: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct rx_buf - RX data event.\n @umac_head: UMAC event header. See &struct umac_hdr.\n @wdev_id: wdev interface id.\n @rx_pkt_cnt: Number of packets received.\n @rx_pkt_type: Rx packet type.\n After receiving the RX packet RPU informs the host using CMD_RX_BUFF.\n Host refills the buffer using CMD_2K_RX_BUFF_CONFIG."]
#[repr(C, packed)]
pub struct rx_buff {
    pub umac_head: umac_head,
    pub rx_pkt_type: ::core::ffi::c_int,
    pub wdev_id: ::core::ffi::c_uchar,
    pub rx_pkt_cnt: ::core::ffi::c_uchar,
    pub rpu_align_offset: ::core::ffi::c_uchar,
    pub mac_header_len: ::core::ffi::c_uchar,
    pub frequency: ::core::ffi::c_ushort,
    pub signal: ::core::ffi::c_short,
    pub rx_buff_info: __IncompleteArrayField<rx_buff_info>,
}
#[doc = " struct data_carrier_state - Carrier state info.\n @umac_head: UMAC event header. See &struct umac_hdr."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct data_carrier_state {
    pub umac_head: umac_head,
    pub wdev_id: ::core::ffi::c_uint,
}
#[doc = " struct sap_client_pwrsave - SofAP client power save info.\n @umac_head: UMAC event header. See &struct umac_hdr.\n @wdev_id: wdev interface id.\n @sta_ps_state: CLIENT_ACTIVE or CLIENT_PS_MODE\n @mac_addr: STA MAC Address"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sap_client_pwrsave {
    pub umac_head: umac_head,
    pub wdev_id: ::core::ffi::c_uint,
    pub sta_ps_state: ::core::ffi::c_uchar,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct sap_ps_get_frames - SofAP client PS get frames info.\n @umac_head: UMAC event header. See &struct umac_hdr.\n @wdev_id: wdev interface id.\n @mac_addr: STA MAC Address\n @num_frames: Num frames to transmit in service period"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sap_ps_get_frames {
    pub umac_head: umac_head,
    pub wdev_id: ::core::ffi::c_uint,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub num_frames: ::core::ffi::c_schar,
}
#[repr(u32)]
#[doc = " enum umac_commands - Commands that the host can send to the RPU.\n\n @UMAC_CMD_TRIGGER_SCAN: Trigger a new scan with the given parameters.\n\tSee &struct umac_cmd_scan\n @UMAC_CMD_GET_SCAN_RESULTS: Request for scan results.\n\tSee &struct umac_cmd_get_scan_results\n @UMAC_CMD_AUTHENTICATE: Send authentication request to AP.\n\tSee &struct umac_cmd_auth\n @UMAC_CMD_ASSOCIATE: Send associate request to AP.\n\tSee &struct umac_cmd_assoc\n @UMAC_CMD_DEAUTHENTICATE: Send deauthentication request to AP.\n\tSee &struct umac_cmd_disconn\n @UMAC_CMD_SET_WIPHY: Set wiphy parameters.\n\tSee &struct umac_cmd_set_wiphy\n @UMAC_CMD_NEW_KEY: Add new key.\n\tSee &struct umac_cmd_key\n @UMAC_CMD_DEL_KEY: Delete crypto key.\n\tSee &struct umac_cmd_key\n @UMAC_CMD_SET_KEY: Set default key to use.\n\tSee &struct umac_cmd_set_key\n @UMAC_CMD_GET_KEY: Unused.\n @UMAC_CMD_NEW_BEACON: Set the beacon fields in AP mode.\n\tSee &struct umac_cmd_start_ap\n @UMAC_CMD_SET_BEACON: Set the beacon fields in AP mode.\n\tSee &struct umac_cmd_set_beacon\n @UMAC_CMD_SET_BSS: Set the BSS.\n\tSee &struct umac_cmd_set_bss\n @UMAC_CMD_START_AP: Start the device as Soft AP.\n\tSee &struct umac_cmd_start_ap\n @UMAC_CMD_STOP_AP: Stop the AP mode.\n\tSee &struct umac_cmd_stop_ap\n @UMAC_CMD_NEW_INTERFACE: Adding interface.\n\tSee &struct umac_cmd_add_vif\n @UMAC_CMD_SET_INTERFACE: Change interface configuration.\n\tSee &struct umac_cmd_chg_vif_attr\n @UMAC_CMD_DEL_INTERFACE: Delete interface.\n\tSee &struct umac_cmd_del_vif\n @UMAC_CMD_SET_IFFLAGS: Change interface flags.\n\tSee &struct umac_cmd_chg_vif_state\n @UMAC_CMD_NEW_STATION: Add a new station.\n\tSee &struct umac_cmd_add_sta\n @UMAC_CMD_DEL_STATION: Delete station.\n\tSee &struct umac_cmd_del_sta\n @UMAC_CMD_SET_STATION: Change station info.\n\tSee &struct umac_cmd_chg_sta\n @UMAC_CMD_GET_STATION: Get station info.\n\tSee &struct umac_cmd_get_sta\n @UMAC_CMD_START_P2P_DEVICE: Start the P2P device.\n\tSee &struct umac_cmd_start_p2p_dev\n @UMAC_CMD_STOP_P2P_DEVICE: Stop the P2P device.\n\tSee &struct umac_cmd_stop_p2p_dev\n @UMAC_CMD_REMAIN_ON_CHANNEL: Unused.\n @UMAC_CMD_CANCEL_REMAIN_ON_CHANNEL: Unused.\n @UMAC_CMD_SET_CHANNEL: Unused.\n @UMAC_CMD_RADAR_DETECT: Unused.\n @UMAC_CMD_REGISTER_FRAME: Whitelist filter based on frame types.\n\tSee &struct umac_cmd_mgmt_frame_reg\n @UMAC_CMD_FRAME: Send a management frame.\n\tSee &struct umac_cmd_mgmt_tx\n @UMAC_CMD_JOIN_IBSS: Unused.\n @UMAC_CMD_WIN_STA_CONNECT: Connect to AP.\n\tSee &struct umac_cmd_win_sta_connect\n @UMAC_CMD_SET_POWER_SAVE: Power save Enable/Disable\n\tSee &struct umac_cmd_set_power_save\n @UMAC_CMD_SET_WOWLAN: Set the WoWLAN trigger configs\n\tSee &struct umac_cmd_set_wowlan\n @UMAC_CMD_SUSPEND: Suspend the bus after WoWLAN configurations\n\tSee &struct umac_cmd_suspend\n @UMAC_CMD_RESUME: Resume the bus activity before wakeup\n\tSee &struct umac_cmd_resume\n @UMAC_CMD_GET_CHANNEL: Get Channel info\n\t\tSee &struct umac_cmd_get_channel\n @UMAC_CMD_GET_TX_POWER: Get Tx power level\n\t\tSee &struct umac_cmd_get_tx_power\n @UMAC_CMD_GET_REG : Get Regulatory info\n\t\tSee &struct reg_t\n @UMAC_CMD_SET_REG : Set Regulatory info\n\t\tSee &struct reg_t\n\n Lists the different ID's to be used to when sending a command to the RPU.\n All the commands are to be encapsulated using struct host_rpu_msg."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum umac_commands {
    UMAC_CMD_TRIGGER_SCAN = 0,
    UMAC_CMD_GET_SCAN_RESULTS = 1,
    UMAC_CMD_AUTHENTICATE = 2,
    UMAC_CMD_ASSOCIATE = 3,
    UMAC_CMD_DEAUTHENTICATE = 4,
    UMAC_CMD_SET_WIPHY = 5,
    UMAC_CMD_NEW_KEY = 6,
    UMAC_CMD_DEL_KEY = 7,
    UMAC_CMD_SET_KEY = 8,
    UMAC_CMD_GET_KEY = 9,
    UMAC_CMD_NEW_BEACON = 10,
    UMAC_CMD_SET_BEACON = 11,
    UMAC_CMD_SET_BSS = 12,
    UMAC_CMD_START_AP = 13,
    UMAC_CMD_STOP_AP = 14,
    UMAC_CMD_NEW_INTERFACE = 15,
    UMAC_CMD_SET_INTERFACE = 16,
    UMAC_CMD_DEL_INTERFACE = 17,
    UMAC_CMD_SET_IFFLAGS = 18,
    UMAC_CMD_NEW_STATION = 19,
    UMAC_CMD_DEL_STATION = 20,
    UMAC_CMD_SET_STATION = 21,
    UMAC_CMD_GET_STATION = 22,
    UMAC_CMD_START_P2P_DEVICE = 23,
    UMAC_CMD_STOP_P2P_DEVICE = 24,
    UMAC_CMD_REMAIN_ON_CHANNEL = 25,
    UMAC_CMD_CANCEL_REMAIN_ON_CHANNEL = 26,
    UMAC_CMD_SET_CHANNEL = 27,
    UMAC_CMD_RADAR_DETECT = 28,
    UMAC_CMD_REGISTER_FRAME = 29,
    UMAC_CMD_FRAME = 30,
    UMAC_CMD_JOIN_IBSS = 31,
    UMAC_CMD_WIN_STA_CONNECT = 32,
    UMAC_CMD_SET_POWER_SAVE = 33,
    UMAC_CMD_SET_WOWLAN = 34,
    UMAC_CMD_SUSPEND = 35,
    UMAC_CMD_RESUME = 36,
    UMAC_CMD_SET_QOS_MAP = 37,
    UMAC_CMD_GET_CHANNEL = 38,
    UMAC_CMD_GET_TX_POWER = 39,
    UMAC_CMD_GET_INTERFACE = 40,
    UMAC_CMD_GET_WIPHY = 41,
    UMAC_CMD_GET_IFHWADDR = 42,
    UMAC_CMD_SET_IFHWADDR = 43,
    UMAC_CMD_GET_REG = 44,
    UMAC_CMD_SET_REG = 45,
    UMAC_CMD_REQ_SET_REG = 46,
    UMAC_CMD_CONFIG_UAPSD = 47,
    UMAC_CMD_CONFIG_TWT = 48,
    UMAC_CMD_TEARDOWN_TWT = 49,
    UMAC_CMD_ABORT_SCAN = 50,
    UMAC_CMD_MCAST_FILTER = 51,
    UMAC_CMD_CHANGE_MACADDR = 52,
    UMAC_CMD_SET_POWER_SAVE_TIMEOUT = 53,
    UMAC_CMD_GET_CONNECTION_INFO = 54,
    UMAC_CMD_GET_POWER_SAVE_INFO = 55,
    UMAC_CMD_SET_LISTEN_INTERVAL = 56,
    UMAC_CMD_CONFIG_EXTENDED_PS = 57,
}
#[repr(u32)]
#[doc = " enum umac_events - Events that the RPU can send to the host.\n\n @UMAC_EVENT_TRIGGER_SCAN_START: Unused.\n @UMAC_EVENT_SCAN_ABORTED: Indicate scan has been cancelled.\n\tSee &struct umac_event_trigger_scan\n @UMAC_EVENT_SCAN_DONE: Indicate scan results are available.\n\tSee &struct umac_event_trigger_scan\n @UMAC_EVENT_SCAN_RESULT: Scan result. We will receive one event for all\n\tthe scan results until umac_hdr->seq == 0.\n\tSee &struct umac_event_new_scan_results\n @UMAC_EVENT_AUTHENTICATE: Authentication status.\n\tSee &struct umac_event_mlme\n @UMAC_EVENT_ASSOCIATE: Association status.\n\tSee &struct umac_event_mlme\n @UMAC_EVENT_CONNECT: Connection complete event.\n\tSee &struct umac_event_connect\n @UMAC_EVENT_DEAUTHENTICATE: Station deauth event.\n\tSee &struct umac_event_mlme\n @UMAC_EVENT_NEW_STATION: Station added indication.\n\tSee &struct umac_event_new_station\n @UMAC_EVENT_DEL_STATION: Station deleted indication.\n\tSee &struct umac_event_new_station\n @UMAC_EVENT_GET_STATION: Station info indication.\n\tSee &umac_event_station_t\n @UMAC_EVENT_REMAIN_ON_CHANNEL: Unused.\n @UMAC_EVENT_CANCEL_REMAIN_ON_CHANNEL: Unused.\n @UMAC_EVENT_DISCONNECT: Unused.\n @UMAC_EVENT_FRAME: RX management frame.\n\tSee &struct umac_event_mlme\n @UMAC_EVENT_COOKIE_RESP: Cookie mapping for UMAC_CMD_FRAME.\n\tSee &struct umac_event_cookie_rsp\n @UMAC_EVENT_FRAME_TX_STATUS: TX management frame transmitted.\n\tSee &struct umac_event_mlme\n @UMAC_EVENT_GET_CHANNEL: Send Channel info.\n\tSee &struct umac_event_get_channel\n @UMAC_EVENT_GET_TX_POWER: Send Tx power.\n\tSee &struct umac_event_get_tx_power\n @UMAC_EVENT_SET_INTERFACE: UMAC_CMD_SET_INTERFACE status.\n\tSee &struct umac_event_set_interface\n @UMAC_EVENT_GET_REG: UMAC_CMD_GET_REG status\n\tSee &struct reg_t\n @UMAC_EVENT_SET_REG: UMAC_CMD_SET_REG status\n\tSee &struct reg_t\n @UMAC_EVENT_REQ_SET_REG: UMAC_CMD_REQ_SET_REG status\n\tSee &struct reg_t\n @UMAC_EVENT_SCAN_DISPLAY_RESULT: Scan display result. We will receive one event for all\n\tthe scan results until umac_hdr->seq == 0\n Lists the ID's to used by the RPU when sending a Event to the Host. All the\n events are encapsulated using struct host_rpu_msg."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum umac_events {
    UMAC_EVENT_UNSPECIFIED = 256,
    UMAC_EVENT_TRIGGER_SCAN_START = 257,
    UMAC_EVENT_SCAN_ABORTED = 258,
    UMAC_EVENT_SCAN_DONE = 259,
    UMAC_EVENT_SCAN_RESULT = 260,
    UMAC_EVENT_AUTHENTICATE = 261,
    UMAC_EVENT_ASSOCIATE = 262,
    UMAC_EVENT_CONNECT = 263,
    UMAC_EVENT_DEAUTHENTICATE = 264,
    UMAC_EVENT_DISASSOCIATE = 265,
    UMAC_EVENT_NEW_STATION = 266,
    UMAC_EVENT_DEL_STATION = 267,
    UMAC_EVENT_GET_STATION = 268,
    UMAC_EVENT_REMAIN_ON_CHANNEL = 269,
    UMAC_EVENT_CANCEL_REMAIN_ON_CHANNEL = 270,
    UMAC_EVENT_DISCONNECT = 271,
    UMAC_EVENT_FRAME = 272,
    UMAC_EVENT_COOKIE_RESP = 273,
    UMAC_EVENT_FRAME_TX_STATUS = 274,
    UMAC_EVENT_IFFLAGS_STATUS = 275,
    UMAC_EVENT_GET_TX_POWER = 276,
    UMAC_EVENT_GET_CHANNEL = 277,
    UMAC_EVENT_SET_INTERFACE = 278,
    UMAC_EVENT_UNPROT_DEAUTHENTICATE = 279,
    UMAC_EVENT_UNPROT_DISASSOCIATE = 280,
    UMAC_EVENT_NEW_INTERFACE = 281,
    UMAC_EVENT_NEW_WIPHY = 282,
    UMAC_EVENT_GET_IFHWADDR = 283,
    UMAC_EVENT_GET_REG = 284,
    UMAC_EVENT_SET_REG = 285,
    UMAC_EVENT_REQ_SET_REG = 286,
    UMAC_EVENT_GET_KEY = 287,
    UMAC_EVENT_BEACON_HINT = 288,
    UMAC_EVENT_REG_CHANGE = 289,
    UMAC_EVENT_WIPHY_REG_CHANGE = 290,
    UMAC_EVENT_SCAN_DISPLAY_RESULT = 291,
    UMAC_EVENT_CMD_STATUS = 292,
    UMAC_EVENT_BSS_INFO = 293,
    UMAC_EVENT_CONFIG_TWT = 294,
    UMAC_EVENT_TEARDOWN_TWT = 295,
    UMAC_EVENT_TWT_SLEEP = 296,
    UMAC_EVENT_COALESCING = 297,
    UMAC_EVENT_MCAST_FILTER = 298,
    UMAC_EVENT_GET_CONNECTION_INFO = 299,
    UMAC_EVENT_GET_POWER_SAVE_INFO = 300,
}
#[repr(u32)]
#[doc = " enum band - Frequency band.\n\n @BAND_2GHZ: 2.4 GHz ISM band.\n @BAND_5GHZ: Around 5 GHz band (4.9 - 5.7 GHz).\n @BAND_60GHZ: Unused.\n\n This enum represents the values that can be used to specify which frequency\n band is used."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum band {
    BAND_2GHZ = 0,
    BAND_5GHZ = 1,
    BAND_60GHZ = 2,
}
#[repr(u32)]
#[doc = " enum mfp - Management frame protection state.\n\n @MFP_NO: Management frame protection not used.\n @MFP_REQUIRED: Management frame protection required.\n\n Enabling/Disabling of Management Frame Protection."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mfp {
    MFP_NO = 0,
    MFP_REQUIRED = 1,
}
#[repr(u32)]
#[doc = " enum key_type - Key Type\n\n @KEYTYPE_GROUP: Group (broadcast/multicast) key\n @KEYTYPE_PAIRWISE: Pairwise (unicast/individual) key\n @KEYTYPE_PEERKEY: Peer key (DLS)\n @NUM_KEYTYPES: Number of defined key types\n\n Lists the different categories of security keys."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum key_type {
    KEYTYPE_GROUP = 0,
    KEYTYPE_PAIRWISE = 1,
    KEYTYPE_PEERKEY = 2,
    NUM_KEYTYPES = 3,
}
impl auth_type {
    pub const AUTHTYPE_MAX: auth_type = auth_type::__AUTHTYPE_NUM;
}
#[repr(u32)]
#[doc = " enum auth_type - Authentication Type.\n\n @AUTHTYPE_OPEN_SYSTEM: Open System authentication.\n @AUTHTYPE_SHARED_KEY: Shared Key authentication (WEP only).\n @AUTHTYPE_FT: Fast BSS Transition (IEEE 802.11r).\n @AUTHTYPE_NETWORK_EAP: Network EAP (some Cisco APs and mainly LEAP).\n @AUTHTYPE_SAE: Simultaneous authentication of equals.\n @__AUTHTYPE_NUM: Internal.\n @AUTHTYPE_MAX: Maximum valid auth algorithm.\n @AUTHTYPE_AUTOMATIC: Determine automatically (if necessary by\n\ttrying multiple times); this is invalid in netlink -- leave out\n\tthe attribute for this on CONNECT commands.\n\n Lists the different types of authentication mechanisms."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum auth_type {
    AUTHTYPE_OPEN_SYSTEM = 0,
    AUTHTYPE_SHARED_KEY = 1,
    AUTHTYPE_FT = 2,
    AUTHTYPE_NETWORK_EAP = 3,
    AUTHTYPE_SAE = 4,
    __AUTHTYPE_NUM = 5,
    AUTHTYPE_AUTOMATIC = 6,
}
#[repr(u32)]
#[doc = " enum hidden_ssid - Hidden SSID usage.\n @HIDDEN_SSID_NOT_IN_USE: Do not hide SSID (i.e., broadcast it in\n\tBeacon frames).\n @HIDDEN_SSID_ZERO_LEN: Hide SSID by using zero-length SSID element\n\tin Beacon frames.\n @HIDDEN_SSID_ZERO_CONTENTS: Hide SSID by using correct length of SSID\n\telement in Beacon frames but zero out each byte in the SSID.\n\n Enable/Disable Hidden SSID feature and also lists the different mechanisms of\n hiding the SSIDs."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum hidden_ssid {
    HIDDEN_SSID_NOT_IN_USE = 0,
    HIDDEN_SSID_ZERO_LEN = 1,
    HIDDEN_SSID_ZERO_CONTENTS = 2,
}
impl smps_mode {
    pub const SMPS_MAX: smps_mode = smps_mode::SMPS_DYNAMIC;
}
#[repr(u32)]
#[doc = " enum smps_mode - SMPS mode.\n @SMPS_OFF: SMPS off (use all antennas).\n @SMPS_STATIC: Static SMPS (use a single antenna).\n @SMPS_DYNAMIC: Dynamic smps (start with a single antenna and\n\tturn on other antennas after CTS/RTS).\n\n Requested SMPS mode (for AP mode)."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum smps_mode {
    SMPS_OFF = 0,
    SMPS_STATIC = 1,
    SMPS_DYNAMIC = 2,
    __SMPS_AFTER_LAST = 3,
}
#[repr(u32)]
#[doc = " enum bss_status - BSS status.\n @BSS_STATUS_AUTHENTICATED: Authenticated with this BSS.\n\tNote that this is no longer used since cfg80211 no longer\n\tkeeps track of whether or not authentication was done with\n\ta given BSS.\n @BSS_STATUS_ASSOCIATED: Associated with this BSS.\n @BSS_STATUS_IBSS_JOINED: Joined to this IBSS.\n\n The BSS status is a BSS attribute in scan dumps, which\n indicates the status the interface has with respect to this BSS."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum bss_status {
    BSS_STATUS_AUTHENTICATED = 0,
    BSS_STATUS_ASSOCIATED = 1,
    BSS_STATUS_IBSS_JOINED = 2,
}
#[repr(u32)]
#[doc = " enum channel_type - Channel type.\n @CHAN_NO_HT: 20 MHz, non-HT channel.\n @CHAN_HT20: 20 MHz HT channel.\n @CHAN_HT40MINUS: HT40 channel, secondary channel\n      below the control channel.\n @CHAN_HT40PLUS: HT40 channel, secondary channel\n      above the control channel.\n\n Lists the different categories of channels."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum channel_type {
    CHAN_NO_HT = 0,
    CHAN_HT20 = 1,
    CHAN_HT40MINUS = 2,
    CHAN_HT40PLUS = 3,
}
#[repr(u32)]
#[doc = " enum chan_width - Channel width definitions.\n\n\n @CHAN_WIDTH_20_NOHT: 20 MHz, non-HT channel.\n @CHAN_WIDTH_20: 20 MHz HT channel.\n @CHAN_WIDTH_40: 40 MHz channel, the %ATTR_CENTER_FREQ1\n\tattribute must be provided as well.\n @CHAN_WIDTH_80: 80 MHz channel, the %ATTR_CENTER_FREQ1\n\tattribute must be provided as well.\n @CHAN_WIDTH_80P80: 80+80 MHz channel, the %ATTR_CENTER_FREQ1\n\tand %ATTR_CENTER_FREQ2 attributes must be provided as well.\n @CHAN_WIDTH_160: 160 MHz channel, the %ATTR_CENTER_FREQ1\n\tattribute must be provided as well.\n @CHAN_WIDTH_5: 5 MHz OFDM channel.\n @CHAN_WIDTH_10: 10 MHz OFDM channel.\n\n Lists the different channel widths."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum chan_width {
    CHAN_WIDTH_20_NOHT = 0,
    CHAN_WIDTH_20 = 1,
    CHAN_WIDTH_40 = 2,
    CHAN_WIDTH_80 = 3,
    CHAN_WIDTH_80P80 = 4,
    CHAN_WIDTH_160 = 5,
    CHAN_WIDTH_5 = 6,
    CHAN_WIDTH_10 = 7,
}
impl iftype {
    pub const IFTYPE_MAX: iftype = iftype::IFTYPE_OCB;
}
#[repr(u32)]
#[doc = " enum iftype - Interface types based on functionality.\n\n @IFTYPE_UNSPECIFIED: Unspecified type, driver decides.\n @IFTYPE_ADHOC: Independent BSS member.\n @IFTYPE_STATION: Managed BSS member.\n @IFTYPE_AP: Access point.\n @IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces\n      are a bit special in that they must always be tied to a pre-existing\n      AP type interface.\n @IFTYPE_WDS: Wireless Distribution System.\n @IFTYPE_MONITOR: Monitor interface receiving all frames.\n @IFTYPE_MESH_POINT: Mesh point.\n @IFTYPE_P2P_CLIENT: P2P client.\n @IFTYPE_P2P_GO: P2P group owner.\n @IFTYPE_P2P_DEVICE: P2P device interface type, this is not a netdev\n\tand therefore can't be created in the normal ways, use the\n\t%UMAC_CMD_START_P2P_DEVICE and %UMAC_CMD_STOP_P2P_DEVICE\n\tcommands (Refer &enum umac_commands) to create and destroy one.\n @IFTYPE_OCB: Outside Context of a BSS.\n\tThis mode corresponds to the MIB variable dot11OCBActivated=true.\n @IFTYPE_MAX: Highest interface type number currently defined.\n @NUM_IFTYPES: Number of defined interface types.\n\n Lists the different interface types based on how they are configured\n functionally."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum iftype {
    IFTYPE_UNSPECIFIED = 0,
    IFTYPE_ADHOC = 1,
    IFTYPE_STATION = 2,
    IFTYPE_AP = 3,
    IFTYPE_AP_VLAN = 4,
    IFTYPE_WDS = 5,
    IFTYPE_MONITOR = 6,
    IFTYPE_MESH_POINT = 7,
    IFTYPE_P2P_CLIENT = 8,
    IFTYPE_P2P_GO = 9,
    IFTYPE_P2P_DEVICE = 10,
    IFTYPE_OCB = 11,
    NUM_IFTYPES = 12,
}
#[repr(u32)]
#[doc = " enum ps_state - powersave state\n @PS_DISABLED: powersave is disabled\n @PS_ENABLED: powersave is enabled"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ps_state {
    PS_DISABLED = 0,
    PS_ENABLED = 1,
}
#[repr(u32)]
#[doc = " enum security_type - WLAN security type\n @WEP: WEP\n @WPA: WPA\n @WPA2: WPA2\n @WPA3: WPA3\n @WAPI: WAPI"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum security_type {
    OPEN = 0,
    WEP = 1,
    WPA = 2,
    WPA2 = 3,
    WPA3 = 4,
    WAPI = 5,
    EAP = 6,
    WPA2_256 = 7,
}
#[repr(u32)]
#[doc = " enum reg_initiator - Indicates the initiator of a reg domain request\n @NL80211_REGDOM_SET_BY_CORE: Core queried CRDA for a dynamic world\n regulatory domain.\n @NL80211_REGDOM_SET_BY_USER: User asked the wireless core to set the\n regulatory domain.\n @NL80211_REGDOM_SET_BY_DRIVER: a wireless drivers has hinted to the\n wireless core it thinks its knows the regulatory domain we should be in.\n @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an\n 802.11 country information element with regulatory information it\n thinks we should consider. cfg80211 only processes the country\n\tcode from the IE, and relies on the regulatory domain information\n\tstructure passed by userspace (CRDA) from our wireless-regdb.\n\tIf a channel is enabled but the country code indicates it should\n\tbe disabled we disable the channel and re-enable it upon disassociation."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum reg_initiator {
    REGDOM_SET_BY_CORE = 0,
    REGDOM_SET_BY_USER = 1,
    REGDOM_SET_BY_DRIVER = 2,
    REGDOM_SET_BY_COUNTRY_IE = 3,
}
#[repr(u32)]
#[doc = " enum reg_type - specifies the type of regulatory domain\n @NL80211_REGDOM_TYPE_COUNTRY: the regulatory domain set is one that pertains\n\tto a specific country. When this is set you can count on the\n\tISO / IEC 3166 alpha2 country code being valid.\n @NL80211_REGDOM_TYPE_WORLD: the regulatory set domain is the world regulatory\n domain.\n @NL80211_REGDOM_TYPE_CUSTOM_WORLD: the regulatory domain set is a custom\n driver specific world regulatory domain. These do not apply system-wide\n and are only applicable to the individual devices which have requested\n them to be applied.\n @NL80211_REGDOM_TYPE_INTERSECTION: the regulatory domain set is the product\n\tof an intersection between two regulatory domains -- the previously\n\tset regulatory domain on the system and the last accepted regulatory\n\tdomain request to be processed."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum reg_type {
    REGDOM_TYPE_COUNTRY = 0,
    REGDOM_TYPE_WORLD = 1,
    REGDOM_TYPE_CUSTOM_WORLD = 2,
    REGDOM_TYPE_INTERSECTION = 3,
}
#[doc = " struct ssid - SSID list.\n @ssid_len: Indicates the number of values in ssid parameter.\n @ssid: SSID (binary attribute, 0..32 octets).\n\n This structure describes the parameters to describe list of SSIDs\n used by the @scan_common parameter in &struct umac_cmd_scan."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ssid {
    pub ssid_len: ::core::ffi::c_uchar,
    pub ssid: [::core::ffi::c_uchar; 32usize],
}
#[doc = " struct ie - Information element(s) data.\n @ie_len: Indicates the number of values in ie parameter.\n @ie: Information element data.\n\n This structure describes the Information element(s) data being passed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ie {
    pub ie_len: ::core::ffi::c_ushort,
    pub ie: [::core::ffi::c_schar; 400usize],
}
#[doc = " struct seq - Transmit key sequence number.\n @seq_len: Length of the seq parameter.\n @seq: Key sequence number data.\n\n Transmit key sequence number (IV/PN) for TKIP and CCMP keys, each six bytes\n in little endian."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct seq {
    pub seq_len: ::core::ffi::c_int,
    pub seq: [::core::ffi::c_uchar; 256usize],
}
#[doc = " struct key - Key data.\n\n @key_len: Length of the key data.\n @key: Key data.\n\n This structure represents a security key data."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct key {
    pub key_len: ::core::ffi::c_uint,
    pub key: [::core::ffi::c_uchar; 256usize],
}
#[doc = " struct umac_sae - SAE element in auth frame.\n\n @sae_data_len: Length of SAE element data.\n @sae_data: SAE element data.\n\n This structure represents SAE elements in Authentication frames.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sae {
    pub sae_data_len: ::core::ffi::c_int,
    pub sae_data: [::core::ffi::c_uchar; 256usize],
}
#[doc = " struct umac_frame - Frame data.\n\n @frame_len: Length of the frame.\n @frame: Frame data.\n\n This structure describes a frame being passed."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct frame {
    pub frame_len: ::core::ffi::c_int,
    pub frame: [::core::ffi::c_schar; 400usize],
}
#[doc = " struct index_ids - UMAC interface index.\n\n @valid_fields: Indicate which properties below are set.\n @wdev_id: wdev id.\n @ifindex: Unused.\n @wiphy_idx: Unused.\n\n Command header expected by UMAC. Legacy header in place to handle requests\n from supplicant in RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct index_ids {
    pub valid_fields: ::core::ffi::c_uint,
    pub ifaceindex: ::core::ffi::c_int,
    pub wiphy_idx: ::core::ffi::c_int,
    pub wdev_id: ::core::ffi::c_ulonglong,
}
#[doc = " struct supp_rates - Scan request parameters.\n\n @valid_fields: Indicate which of the following parameters are valid.\n @band: Frequency band, see enum umac_band.\n @num_rates: Number of values in rates parameter.\n @rates: Rates per to be advertised as supported in scan,\n\t nested array attribute containing an entry for each band, with the\n\t entry being a list of supported rates as defined by IEEE 802.11\n\t 7.3.2.2 but without the length restriction (at most\n\t %MAX_SUPP_RATES).\n\n This structure specifies the parameters to be used when sending\n %UMAC_CMD_TRIGGER_SCAN command (Refer &enum umac_commands).\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct supp_rates {
    pub valid_fields: ::core::ffi::c_uint,
    pub band: ::core::ffi::c_int,
    pub num_rates: ::core::ffi::c_int,
    pub rates: [::core::ffi::c_uchar; 60usize],
}
#[doc = " struct channel - channel definition\n\n This structure describes a single channel for use.\n\n @center_frequency: center frequency in MHz\n @hw_value: hardware-specific value for the channel\n @flags: channel flags from &enum channel_flags.\n @orig_flags: channel flags at registration time, used by regulatory\n code to support devices with additional restrictions\n @band: band this channel belongs to.\n @max_antenna_gain: maximum antenna gain in dBi\n @max_power: maximum transmission power (in dBm)\n @max_reg_power: maximum regulatory transmission power (in dBm)\n @beacon_found: helper to regulatory code to indicate when a beacon\n has been found on this channel. Use regulatory_hint_found_beacon()\n to enable this, this is useful only on 5 GHz band.\n @orig_mag: internal use\n @orig_mpwr: internal use"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct channel {
    pub band: ::core::ffi::c_int,
    pub center_frequency: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_uint,
    pub max_antenna_gain: ::core::ffi::c_int,
    pub max_power: ::core::ffi::c_int,
    pub max_reg_power: ::core::ffi::c_int,
    pub orig_flags: ::core::ffi::c_uint,
    pub orig_mag: ::core::ffi::c_int,
    pub orig_mpwr: ::core::ffi::c_int,
    pub hw_value: ::core::ffi::c_ushort,
    pub beacon_found: ::core::ffi::c_schar,
}
#[doc = " struct scan_params - Scan request parameters.\n\n @valid_fields: Indicate which of the following parameters are valid.\n @num_scan_ssids: Number of elements in scan_ssids parameter.\n @scan_ssids: Nested attribute with SSIDs, leave out for passive\n\t scanning and include a zero-length SSID (wildcard) for wildcard scan.\n @ie: Information element(s) data.\n @num_scan_channels: Num of scan channels.\n @scan_frequencies: Channel information.\n @mac_addr: MAC address (various uses).\n @mac_addr_mask: MAC address mask.\n @scan_flags: Scan request control flags (u32). Bit values\n\t(SCAN_FLAG_LOW_PRIORITY/SCAN_FLAG_RANDOM_ADDR...)\n @supp_rates: Supported rates.\n @no_cck: used to send probe requests at non CCK rate in 2GHz band\n @oper_ch__duration: Operating channel duration when STA is connected to AP\n @scan_duration: Max scan duration in TU\n @channels: See struct channel\n\n This structure specifies the parameters to be used when sending\n %UMAC_CMD_TRIGGER_SCAN command (Refer &enum umac_commands)."]
#[repr(C, packed)]
pub struct scan_params {
    pub valid_fields: ::core::ffi::c_uint,
    pub num_scan_ssids: ::core::ffi::c_uchar,
    pub num_scan_channels: ::core::ffi::c_uchar,
    pub scan_flags: ::core::ffi::c_uint,
    pub scan_ssids: [ssid; 2usize],
    pub ie: ie,
    pub supp_rates: supp_rates,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub mac_addr_mask: [::core::ffi::c_uchar; 6usize],
    pub no_cck: ::core::ffi::c_uchar,
    pub oper_ch_duration: ::core::ffi::c_ushort,
    pub scan_duration: [::core::ffi::c_ushort; 42usize],
    pub probe_cnt: [::core::ffi::c_uchar; 42usize],
    pub channels: __IncompleteArrayField<channel>,
}
#[doc = " struct ht_vht_capabilities - VHT capability information.\n @valid_fields: Indicate which of the following parameters are valid.\n @ht_capability: HT Capability information element (from\n\tassociation request when used with %UMAC_CMD_NEW_STATION in\n\t&enum umac_commands).\n @ht_capability_mask: Specify which bits of the\n\tATTR_HT_CAPABILITY to which attention should be paid.\n\tThe values that may be configured are:\n\tMCS rates, MAX-AMSDU, HT-20-40 and HT_CAP_SGI_40\n\tAMPDU density and AMPDU factor.\n\tAll values are treated as suggestions and may be ignored\n\tby the driver as required.\n @vht_capability: VHT Capability information element (from\n\tassociation request when used with %UMAC_CMD_NEW_STATION in\n\t&enum umac_commands).\n @vht_capability_mask: Specify which bits in vht_capability to which attention\n\tshould be paid.\n @flags: Indicate which capabilities have been specified.\n\n This structure encapsulates the VHT capability information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ht_vht_capabilities {
    pub valid_fields: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_ushort,
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    pub ht_capability_mask: [::core::ffi::c_uchar; 256usize],
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    pub vht_capability_mask: [::core::ffi::c_uchar; 256usize],
}
#[doc = " struct signal - Signal information.\n\n @signal_type: MBM or unspecified.\n @signal: If MBM signal strength of probe response/beacon\n\tin mBm (100 * dBm) (s32)\n\tIf unspecified signal strength of the probe response/beacon\n\tin unspecified units, scaled to 0..100 (u8).\n\n This structure represents signal information."]
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct signal {
    pub signal_type: ::core::ffi::c_uint,
    pub signal: signal__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub union signal__bindgen_ty_1 {
    pub mbm_signal: ::core::ffi::c_uint,
    pub unspec_signal: ::core::ffi::c_uchar,
}
#[doc = " struct connect_common_info - Connection properties.\n\n @valid_fields: Indicate which of the following parameters are valid.\n @mac_addr: MAC address (various uses).\n @mac_addr_hint: MAC address recommendation as initial BSS.\n @frequency: Frequency of the selected channel in MHz, defines the channel\n\ttogether with the (deprecated) %UMAC_ATTR_WIPHY_CHANNEL_TYPE\n\tattribute or the attributes %UMAC_ATTR_CHANNEL_WIDTH and if needed\n\t%UMAC_ATTR_CENTER_FREQ1 and %UMAC_ATTR_CENTER_FREQ2.\n @freq_hint: Frequency of the recommended initial BS.\n @bg_scan_period: Background scan period in seconds or 0 to disable\n\tbackground scan.\n @ssid: SSID (binary attribute, 0..32 octets).\n @wpa_ie: Information element(s) data.\n @wpa_versions: Used with CONNECT, ASSOCIATE, and NEW_BEACON to\n\tindicate which WPA version(s) the AP we want to associate with is using\n @num_cipher_suites_pairwise: Number of pairwise cipher suites.\n @cipher_suites_pairwise: For crypto settings for connect or\n\tother commands, indicates which pairwise cipher suites are used.\n @cipher_suite_group: For crypto settings for connect or\n\tother commands, indicates which group cipher suite is used.\n @num_akm_suites: Number of groupwise cipher suites.\n @akm_suites: Used with CONNECT, ASSOCIATE, and NEW_BEACON to\n\tindicate which key management algorithm(s) to use (an array of u32).\n @use_mfp: Whether management frame protection (IEEE 802.11w) is\n\tused for the association; this attribute can be used\n\twith %UMAC_CMD_ASSOCIATE and %UMAC_CMD_CONNECT requests (Refer\n\t&enum umac_commands).\n @ht_vht_capabilitys: VHT Capability information element (from\n\tassociation request when used with %UMAC_CMD_NEW_STATION in\n\t&enum umac_commands).\n @flags: Flag for indicating whether the current connection\n\tshall support Radio Resource Measurements (11k). This attribute can be\n\tused with %UMAC_CMD_ASSOCIATE and %UMAC_CMD_CONNECT requests\n\t(Refer &enum umac_commands).\n\tUser space applications are expected to use this flag only if the\n\tunderlying device supports these minimal RRM features:\n\t%UMAC_FEATURE_DS_PARAM_SET_IE_IN_PROBES,\n\t%UMAC_FEATURE_QUIET,\n\tIf this flag is used, driver must add the Power Capabilities IE to the\n\tassociation request. In addition, it must also set the RRM capability\n\tflag in the association request's Capability Info field.\n\tflag indicating whether user space controls\n\tIEEE 802.1X port, i.e., sets/clears %UMAC_STA_FLAG_AUTHORIZED, in\n\tstation mode. If the flag is included in %UMAC_CMD_ASSOCIATE\n\trequest, the driver will assume that the port is unauthorized until\n\tauthorized by user space. Otherwise, port is marked authorized by\n\tdefault in station mode.\n\n This structure specifies the parameters to be used when building\n connect_common_info when sending %UMAC_CMD_ASSOCIATE command (Refer\n &enum umac_commands)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct connect_common_info {
    pub valid_fields: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_uint,
    pub freq_hint: ::core::ffi::c_uint,
    pub wpa_versions: ::core::ffi::c_uint,
    pub num_cipher_suites_pairwise: ::core::ffi::c_int,
    pub cipher_suites_pairwise: [::core::ffi::c_uint; 7usize],
    pub cipher_suite_group: ::core::ffi::c_uint,
    pub num_akm_suites: ::core::ffi::c_uint,
    pub akm_suites: [::core::ffi::c_uint; 2usize],
    pub use_mfp: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_uint,
    pub bg_scan_period: ::core::ffi::c_ushort,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub mac_addr_hint: [::core::ffi::c_uchar; 6usize],
    pub ssid: ssid,
    pub wpa_ie: ie,
    pub ht_vht_capabilities: ht_vht_capabilities,
    pub control_port_ether_type: ::core::ffi::c_ushort,
    pub control_port_no_encrypt: ::core::ffi::c_uchar,
    pub control_port: ::core::ffi::c_schar,
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    pub maxidle_insec: ::core::ffi::c_ushort,
}
#[doc = " struct beacon_data - beacon & probe data\n @head_len: length of @head\n @tail_len: length of @tail\n @probe_resp_len: length of probe response template (@probe_resp)\n @head: head portion of beacon (before TIM IE) or %NULL if not changed\n @tail: tail portion of beacon (after TIM IE) or %NULL if not changed\n @probe_resp: probe response template"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct beacon_data {
    pub head_len: ::core::ffi::c_uint,
    pub tail_len: ::core::ffi::c_uint,
    pub probe_resp_len: ::core::ffi::c_uint,
    pub head: [::core::ffi::c_uchar; 256usize],
    pub tail: [::core::ffi::c_uchar; 512usize],
    pub probe_resp: [::core::ffi::c_uchar; 400usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sta_flag_update {
    pub mask: ::core::ffi::c_uint,
    pub set: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct rate_info {
    pub valid_fields: ::core::ffi::c_uint,
    pub bitrate: ::core::ffi::c_uint,
    pub bitrate_compat: ::core::ffi::c_ushort,
    pub mcs: ::core::ffi::c_uchar,
    pub vht_mcs: ::core::ffi::c_uchar,
    pub vht_nss: ::core::ffi::c_uchar,
    pub flags: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sta_bss_parameters {
    pub flags: ::core::ffi::c_uchar,
    pub dtim_period: ::core::ffi::c_uchar,
    pub beacon_interval: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sta_info {
    pub valid_fields: ::core::ffi::c_uint,
    pub connected_time: ::core::ffi::c_uint,
    pub inactive_time: ::core::ffi::c_uint,
    pub rx_bytes: ::core::ffi::c_uint,
    pub tx_bytes: ::core::ffi::c_uint,
    pub chain_signal_mask: ::core::ffi::c_uint,
    pub chain_signal: [::core::ffi::c_uchar; 4usize],
    pub chain_signal_avg_mask: ::core::ffi::c_uint,
    pub chain_signal_avg: [::core::ffi::c_uchar; 4usize],
    pub tx_bitrate: rate_info,
    pub rx_bitrate: rate_info,
    pub llid: ::core::ffi::c_ushort,
    pub plid: ::core::ffi::c_ushort,
    pub plink_state: ::core::ffi::c_uchar,
    pub signal: ::core::ffi::c_int,
    pub signal_avg: ::core::ffi::c_int,
    pub rx_packets: ::core::ffi::c_uint,
    pub tx_packets: ::core::ffi::c_uint,
    pub tx_retries: ::core::ffi::c_uint,
    pub tx_failed: ::core::ffi::c_uint,
    pub expected_throughput: ::core::ffi::c_uint,
    pub beacon_loss_count: ::core::ffi::c_uint,
    pub local_pm: ::core::ffi::c_uint,
    pub peer_pm: ::core::ffi::c_uint,
    pub nonpeer_pm: ::core::ffi::c_uint,
    pub sta_flags: sta_flag_update,
    pub t_offset: ::core::ffi::c_ulonglong,
    pub rx_dropped_misc: ::core::ffi::c_ulonglong,
    pub rx_beacon: ::core::ffi::c_ulonglong,
    pub rx_beacon_signal_avg: ::core::ffi::c_longlong,
    pub bss_param: sta_bss_parameters,
}
#[doc = " struct umac_hdr - Common command/event header.\n\n @cmd_evnt: UMAC command/event value. (Refer\t&enum umac_commands).\n @ids: Interface properties.\n\n Command header expected by UMAC. Legacy header in place to handle requests\n from supplicant in RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_hdr {
    pub portid: ::core::ffi::c_uint,
    pub seq: ::core::ffi::c_uint,
    pub cmd_evnt: ::core::ffi::c_uint,
    pub rpu_ret_val: ::core::ffi::c_int,
    pub ids: index_ids,
}
#[doc = " struct umac_key_info - Key information.\n\n @valid_fields: Indicate which of the following parameters are valid.\n @key: Key data, see &struct key.\n @key_type: Key Type,\tsee &enum key_type\n @key_idx: Key ID (0-3).\n @seq: Transmit key sequence number (IV/PN) for TKIP and\n\tCCMP keys, each six bytes in little endian.\n @cipher_suite: Key cipher suite (as defined by IEEE 802.11\n\tsection 7.3.2.25.1).\n @flags: A nested attribute containing flags\n\tattributes, specifying what a key should be set as default as.\n\n This structure represents a security key."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_key_info {
    pub valid_fields: ::core::ffi::c_uint,
    pub cipher_suite: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_ushort,
    pub key_type: ::core::ffi::c_int,
    pub key: key,
    pub seq: seq,
    pub key_idx: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_key {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub key_idx: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_get_key {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub key_info: umac_key_info,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[repr(u32)]
#[doc = " enum scan_mode - scan operation mode\n @AUTO: auto or legacy scan operation\n @CHANNEL_MAPPING_SCAN: channel mapping mode. most of parameters will come from host.\n\n This enum represents the different types of scanning operations."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum scan_mode {
    AUTO_SCAN = 0,
    CHANNEL_MAPPING_SCAN = 1,
}
#[repr(u32)]
#[doc = " enum scan_reason - scan reason\n @SCAN_DISPLAY: scan for display purpose in user space\n @SCAN_CONNECT: scan for connection purpose.\n\n This enum represents the different types of scan reasons."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum scan_reason {
    SCAN_DISPLAY = 0,
    SCAN_CONNECT = 1,
}
#[doc = " struct umac_scan_info - Scan related information.\n\n @scan_mode:see enum scan_mode .\n @scan_reason:see enum scan_reason .\n @scan_params: Refer to &struct umac_scan_params.\n\n Properties to be used when triggering a new scan request"]
#[repr(C, packed)]
pub struct umac_scan_info {
    pub scan_mode: ::core::ffi::c_int,
    pub scan_reason: ::core::ffi::c_int,
    pub scan_params: scan_params,
}
#[doc = " struct umac_cmd_scan - Scan request properties.\n\n @umac_hdr: Refer to &struct umac_hdr.\n @info: Refer to &struct umac_scan_info.\n\n Properties to be used when triggering a new scan request"]
#[repr(C, packed)]
pub struct umac_cmd_scan {
    pub umac_hdr: umac_hdr,
    pub info: umac_scan_info,
}
#[doc = " struct umac_cmd_abort_scan - Abort Scan request.\n\n @umac_hdr: Refer to &struct umac_hdr.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_abort_scan {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_cmd_get_scan_results - Get scan results.\n\n @umac_hdr: Refer to &struct umac_hdr.\n @scan_reason: Refer to &enum scan_reason.\n\n Properties to be used when requesting for scan results. This should be\n allowed only if we received a %UMAC_EVENT_SCAN_DONE for a\n %UMAC_CMD_TRIGGER_SCAN earlier."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_scan_results {
    pub umac_hdr: umac_hdr,
    pub scan_reason: ::core::ffi::c_int,
}
#[doc = " struct umac_event_scan_done - Scan Done event.\n\n @umac_hdr: Refer to &struct img_umac_hdr.\n @status :\t0->Scan successful\n\t\t\t\t1->Scan aborted\n @scan_type:\t0->display_scan\n\t\t\t\t1->connect_scan\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_scan_done {
    pub umac_hdr: umac_hdr,
    pub status: ::core::ffi::c_int,
    pub scan_type: ::core::ffi::c_uint,
}
#[doc = " struct umac_mcast_cfg - mcast related information.\n\n @type: Add (0) or Delete (1)\n @mac-addr: multicast address to be added/deleted."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_mcast_cfg {
    pub type_: ::core::ffi::c_uint,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct umac_cmd_mcast_filter - set mcast address\n\n @umac_hdr: Refer to &struct umac_hdr.\n @info: Refer to &struct umac_mcast_cfg.\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_mcast_filter {
    pub umac_hdr: umac_hdr,
    pub info: umac_mcast_cfg,
}
#[doc = " struct umac_cmd_change_macaddr - Change MAC Address\n\n    - This has to be used only when the interface is down.\n\n @umac_hdr: Refer to &struct img_umac_hdr.\n @mac_addr : MAC address to be set\n"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_change_macaddr_info {
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_change_macaddr {
    pub umac_hdr: umac_hdr,
    pub macaddr_info: umac_change_macaddr_info,
}
#[doc = " struct umac_auth_info - Authentication command parameters.\n\n @frequency: Frequency of the selected channel in MHz,\n\t defines the channel together with the (deprecated)\n\t %UMAC_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes\n\t %UMAC_ATTR_CHANNEL_WIDTH and if needed %UMAC_ATTR_CENTER_FREQ1\n\t and %UMAC_ATTR_CENTER_FREQ2.\n @flags: Flag attribute to indicate that a command\n\t is requesting a local authentication/association state change without\n\t invoking actual management frame exchange. This can be used with\n\t %UMAC_CMD_AUTHENTICATE, %UMAC_CMD_DEAUTHENTICATE\n\t (Refer &enum umac_commands).\n @auth_type: Authentication type.\n @key_info: Key information in a nested attribute with\n\t %UMAC_KEY_* sub-attributes.\n @ssid: SSID (binary attribute, 0..32 octets).\n @ie: Information element(s) data.\n @sae: SAE elements in Authentication frames. This starts\n\t with the Authentication transaction sequence number field.\n @bssid: MAC address (various uses).\n\n This structure specifies the parameters to be used when sending auth request."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_auth_info {
    pub frequency: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_ushort,
    pub auth_type: ::core::ffi::c_int,
    pub key_info: umac_key_info,
    pub ssid: ssid,
    pub ie: ie,
    pub sae: sae,
    pub bssid: [::core::ffi::c_uchar; 6usize],
    pub scan_width: ::core::ffi::c_int,
    pub signal: ::core::ffi::c_int,
    pub from_beacon: ::core::ffi::c_int,
    pub bss_ie: ie,
    pub capability: ::core::ffi::c_ushort,
    pub beacon_interval: ::core::ffi::c_ushort,
    pub tsf: ::core::ffi::c_ulonglong,
}
#[doc = " struct umac_cmd_auth - Authentication command structure.\n\n @umac_hdr: UMAC command header. See &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Information to be passed along with the authentication command.\n\tSee &struct umac_auth_info.\n\n This structure specifies the format to be used when sending an auth request."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_auth {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_auth_info,
}
#[doc = " struct umac_assoc_info - Association command parameters.\n\n @center_frequency: Frequency of the selected channel in MHz, defines the channel\n\ttogether with the (deprecated)\n\t%UMAC_ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes\n\t%UMAC_ATTR_CHANNEL_WIDTH and if needed\n\t%UMAC_ATTR_CENTER_FREQ1 and %UMAC_ATTR_CENTER_FREQ2.\n @ssid: SSID (binary attribute, 0..32 octets).\n @wpa_ie: WPA information element data.\n @bssid: MAC address (various uses).\n\n This structure specifies the parameters to be used when sending an assoc\n request."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_assoc_info {
    pub center_frequency: ::core::ffi::c_uint,
    pub ssid: ssid,
    pub bssid: [::core::ffi::c_uchar; 6usize],
    pub wpa_ie: ie,
    pub use_mfp: ::core::ffi::c_uchar,
    pub control_port: ::core::ffi::c_schar,
    pub prev_bssid_flag: ::core::ffi::c_uint,
    pub prev_bssid: [::core::ffi::c_uchar; 6usize],
    pub bss_max_idle_time: ::core::ffi::c_ushort,
}
#[doc = " struct umac_cmd_assoc - Association command parameters\n\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @connect_common_info: Connection attributes.\n @mac_addr: Previous BSSID, to be used by in ASSOCIATE commands to specify\n\tusing a reassociate frame.\n\n This structure specifies the parameters to be used when sending\n %UMAC_CMD_ASSOCIATE command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_assoc {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub connect_common_info: connect_common_info,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct umac_disconn_info - Parameters to be used along with any of the\n\tdisconnection commands.\n\n @flags: Flag attribute to indicate that a command is requesting a local\n\tdeauthentication/disassociation state change without invoking\n\tactual management frame exchange. This can be used with\n\t%UMAC_CMD_DISASSOCIATE, %UMAC_CMD_DEAUTHENTICATE\n\t(Refer &enum umac_commands).\n @reason_code: ReasonCode for disassociation or deauthentication.\n @mac_addr: MAC address (various uses).\n\n This structure specifies the parameters to be used when sending any of the\n disconnection commands i.e. %UMAC_CMD_DISCONNECT (or)\n %UMAC_CMD_DISASSOCIATE (or) %UMAC_CMD_DEAUTHENTICATE."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_disconn_info {
    pub flags: ::core::ffi::c_ushort,
    pub reason_code: ::core::ffi::c_ushort,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct umac_cmd_disconn - Disconnection command parameters\n\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n\n This structure specifies the parameters to be used when sending\n %UMAC_CMD_DISCONNECT (or) %UMAC_CMD_DISASSOCIATE (or)\n %UMAC_CMD_DEAUTHENTICATE."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_disconn {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_disconn_info,
}
#[doc = " struct umac_add_vif_info - Information for creating a new virtual\n\tinterface.\n\n @iftype: Interface type, see enum sys_iftype.\n @use_4addr: Use 4-address frames on a virtual interface.\n @mon_flags: Monitor configuration flags.\n @mac_addr: MAC Address.\n @ifacename: Interface name.\n\n This structure represents the information to be passed to the RPU to\n create a new virtual interface using the %UMAC_CMD_NEW_INTERFACE\n command."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_add_vif_info {
    pub iftype: ::core::ffi::c_int,
    pub use_4addr: ::core::ffi::c_int,
    pub mon_flags: ::core::ffi::c_uint,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[doc = " struct umac_cmd_add_vif - Create a new virtual interface\n\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: VIF specific information to be passed to the RPU.\n\n This structure represents a command to be passed to inform the RPU to\n create a new virtual interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_add_vif {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_add_vif_info,
}
#[doc = " struct umac_cmd_del_vif - Delete a virtual interface\n\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents a command to be passed to inform the RPU to\n delete a virtual interface. This cmd is not allowed on default interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_del_vif {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_frame_match - Frame data to match for RX filter.\n @frame_match_len: Length of data.\n @frame_match: Data to match.\n\n This structure represents the frame data to match so that the RPU RX filter\n can pass up the matching frames."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_frame_match {
    pub frame_match_len: ::core::ffi::c_uint,
    pub frame_match: [::core::ffi::c_uchar; 8usize],
}
#[doc = " struct umac_mgmt_frame_info - Information regarding management frame to\n\tbe registered to be received.\n @frame_type: Frame type/subtype.\n @frame_match: A binary attribute which typically must contain at least one\n\tbyte.\n\n This structure represents information regarding a management frame which\n should not be filtered by the RPU and passed up."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_mgmt_frame_info {
    pub frame_type: ::core::ffi::c_ushort,
    pub frame_match: umac_frame_match,
}
#[doc = " struct umac_cmd_mgmt_frame_reg - Register management frame type to be\n\treceived.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr\n @info: Management frame specific information to be passed to the RPU.\n\n This structure represents a command to be passed to inform the RPU to\n register a management frame which should not be filtered by the RPU and\n passed up."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_mgmt_frame_reg {
    pub umac_hdr: umac_hdr,
    pub info: umac_mgmt_frame_info,
}
#[doc = " struct umac_cmd_key - Parameters when adding new key\n\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @key_info: Key information in a nested attribute with\n\t%UMAC_KEY_* sub-attributes.\n @mac_addr: MAC address associated with the key.\n\n This structure represents a command to add a new key."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_key {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub key_info: umac_key_info,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct umac_set_key - Parameters when setting default key.\n\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @key_info: Key information in a nested attribute with\n\t%UMAC_KEY_* sub-attributes.\n\n This structure represents a command to set a default key."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_key {
    pub umac_hdr: umac_hdr,
    pub key_info: umac_key_info,
}
#[doc = " struct umac_bss_info - BSS attributes.\n @p2p_go_ctwindow: P2P GO Client Traffic Window, used with\n\tthe START_AP and SET_BSS commands.\n @p2p_opp_ps: P2P GO opportunistic PS, used with the\n\tSTART_AP and SET_BSS commands. This can have the values 0 or 1;\n\tif not given in START_AP 0 is assumed, if not given in SET_BSS\n\tno change is made.\n @num_basic_rates: Number of basic rate elements.\n @ht_opmode: HT operation mode.\n @cts: Whether CTS protection is enabled (0 or 1).\n @preamble: Whether short preamble is enabled (0 or 1).\n @slot: Whether short slot time enabled (0 or 1).\n @ap_isolate: (AP mode) Do not forward traffic between stations connected to\n\tthis BSS.\n @basic_rates: Basic rates, array of basic rates in format defined by\n\tIEEE 802.11 7.3.2.2 but without the length restriction\n\t(at most %MAX_SUPP_RATES).\n\n This structure represents the BSS attributes."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_bss_info {
    pub p2p_go_ctwindow: ::core::ffi::c_uint,
    pub p2p_opp_ps: ::core::ffi::c_uint,
    pub num_basic_rates: ::core::ffi::c_uint,
    pub ht_opmode: ::core::ffi::c_ushort,
    pub cts: ::core::ffi::c_uchar,
    pub preamble: ::core::ffi::c_uchar,
    pub slot: ::core::ffi::c_uchar,
    pub ap_isolate: ::core::ffi::c_uchar,
    pub basic_rates: [::core::ffi::c_uchar; 32usize],
}
#[doc = " struct umac_cmd_set_bss - Set BSS attributes.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid\n @bss_info: BSS specific information to be passed to the RPU.\n\n This structure represents a command to set BSS attributes."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_bss {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub bss_info: umac_bss_info,
}
#[doc = " struct freq_params - Frequency configuration.\n @valid_fields: Indicate which of the following parameters are valid.\n @frequency: Value in MHz.\n @channel_width: Width of the channel (refer &enum chan_width).\n @channel_type: Type of channel (refer &enum channel_type).\n\n This structure represents a frequency parameters to be set."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct freq_params {
    pub valid_fields: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_int,
    pub channel_width: ::core::ffi::c_int,
    pub center_frequency1: ::core::ffi::c_int,
    pub center_frequency2: ::core::ffi::c_int,
    pub channel_type: ::core::ffi::c_int,
}
#[doc = " struct umac_cmd_set_channel - Set channel configuration.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following structure parameters are valid.\n @freq_params: Information related to channel parameters\n\n This structure represents the command to set the wireless channel configuration."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_channel {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub freq_params: freq_params,
}
#[doc = " struct txq_params - TX queue parameter attributes.\n @txop: Transmit oppurtunity.\n @cwmin: Minimum contention window.\n @cwmax: Maximum contention window.\n @aifs: Arbitration interframe spacing.\n @ac: Access category.\n\n This structure represents transmit queue parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct txq_params {
    pub txop: ::core::ffi::c_ushort,
    pub cwmin: ::core::ffi::c_ushort,
    pub cwmax: ::core::ffi::c_ushort,
    pub aifs: ::core::ffi::c_uchar,
    pub ac: ::core::ffi::c_uchar,
}
#[repr(u32)]
#[doc = " enum tx_power_type - TX power adjustment.\n @TX_POWER_AUTOMATIC: Automatically determine transmit power.\n @TX_POWER_LIMITED: Limit TX power by the mBm parameter.\n @TX_POWER_FIXED: Fix TX power to the mBm parameter.\n\n Types of transmit power settings."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum tx_power_type {
    TX_POWER_AUTOMATIC = 0,
    TX_POWER_LIMITED = 1,
    TX_POWER_FIXED = 2,
}
#[doc = " struct tx_power_setting - TX power configuration.\n @valid_fields: Indicate which of the following parameters are valid.\n @type: Power value type, see tx_power_type.\n @tx_power_level: Transmit power level in signed mBm units.\n\n This structure represents the transmit power setting parameters."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_power_setting {
    pub valid_fields: ::core::ffi::c_uint,
    pub type_: ::core::ffi::c_int,
    pub tx_power_level: ::core::ffi::c_int,
}
#[doc = " struct umac_set_wiphy_info - wiphy configuration.\n @rts_threshold: RTS threshold (TX frames with length\n\tlarger than or equal to this use RTS/CTS handshake); allowed range:\n\t0..65536, disable with (u32)-1.\n @frag_threshold: Fragmentation threshold, i.e., maximum\n\tlength in octets for frames; allowed range: 256..8000, disable\n\tfragmentation with (u32)-1.\n @antenna_tx: Bitmap of allowed antennas for transmitting.\n\tThis can be used to mask out antennas which are not attached or should\n\tnot be used for transmitting. If an antenna is not selected in this\n\tbitmap the hardware is not allowed to transmit on this antenna.\n @antenna_rx: Bitmap of allowed antennas for receiving.\n\tThis can be used to mask out antennas which are not attached or should\n\tnot be used for receiving. If an antenna is not selected in this bitmap\n\tthe hardware should not be configured to receive on this antenna.\n @freq_params: Frequency of the selected channel in MHz,\n\tdefines the channel together with the (deprecated)\n\t%ATTR_WIPHY_CHANNEL_TYPE attribute or the attributes\n\t%ATTR_CHANNEL_WIDTH and if needed %ATTR_CENTER_FREQ1\n\tand %ATTR_CENTER_FREQ2.\n @txq_params: A nested array of TX queue parameters.\n @tx_power_setting: Transmit power setting type. See\n\t&enum tx_power_setting for possible values.\n @retry_short: TX retry limit for frames whose length is\n\tless than or equal to the RTS threshold; allowed range: 1..255.\n @retry_long: TX retry limit for frames whose length is\n\tgreater than the RTS threshold; allowed range: 1..255.\n @coverage_class:Coverage Class as defined by IEEE 802.11\n\tsection 7.3.2.9.\n @wiphy_name: WIPHY name (used for renaming).\n\n This structure represents the wireless PHY configuration."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_set_wiphy_info {
    pub rts_threshold: ::core::ffi::c_uint,
    pub frag_threshold: ::core::ffi::c_uint,
    pub antenna_tx: ::core::ffi::c_uint,
    pub antenna_rx: ::core::ffi::c_uint,
    pub freq_params: freq_params,
    pub txq_params: txq_params,
    pub tx_power_setting: tx_power_setting,
    pub retry_short: ::core::ffi::c_uchar,
    pub retry_long: ::core::ffi::c_uchar,
    pub coverage_class: ::core::ffi::c_uchar,
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
}
#[doc = " struct umac_cmd_set_wiphy - Set wiphy configuration.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following structure parameters are valid.\n @info: Information related to wiphy parameters\n\n This structure represents the command to set the wireless PHY configuration."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_wiphy {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_set_wiphy_info,
}
#[doc = " struct umac_del_sta_info - Information regarding a station to be\n\tdeleted.\n @mac_addr: MAC address of the station.\n @mgmt_subtype: Management frame subtype.\n @reason_code: Reason code for DEAUTHENTICATION and DISASSOCIATION.\n\n This structure represents the information regarding a station to be deleted\n from the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_del_sta_info {
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub mgmt_subtype: ::core::ffi::c_uchar,
    pub reason_code: ::core::ffi::c_ushort,
}
#[doc = " struct umac_cmd_del_sta - Delete a station entry.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Information regarding the station to be deleted.\n\n This structure represents the command to delete a station."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_del_sta {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_del_sta_info,
}
#[doc = " struct umac_get_sta_info - Station information get.\n @mac_addr: MAC address of the station.\n This structure represents the information regarding a station info to be get."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_get_sta_info {
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct umac_cmd_get_sta - Get a station info.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: Information regarding the station to get.\n\n This structure represents the command to get station info."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_sta {
    pub umac_hdr: umac_hdr,
    pub info: umac_get_sta_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct ext_capability {
    pub ext_capability_len: ::core::ffi::c_uint,
    pub ext_capability: [::core::ffi::c_uchar; 32usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct supported_channels {
    pub supported_channels_len: ::core::ffi::c_uint,
    pub supported_channels: [::core::ffi::c_uchar; 64usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct supported_oper_classes {
    pub supported_oper_classes_len: ::core::ffi::c_uint,
    pub supported_oper_classes: [::core::ffi::c_uchar; 64usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct sta_flags2 {
    pub sta_flags2_len: ::core::ffi::c_uint,
    pub sta_flags2: [::core::ffi::c_uchar; 64usize],
}
#[doc = " struct umac_chg_sta_info - Information about station entry to be updated.\n @listen_interval: Listen interval as defined by IEEE 802.11 7.3.1.6.\n @sta_vlan: Vlan interface station should belong to.\n @aid: AID or zero for no change.\n @peer_aid: Unused.\n @sta_capability: Station capability.\n @spare: Unused.\n @supp_rates: Supported rates in IEEE 802.11 format.\n @ext_capability: Extended capabilities of the station.\n @supported_channels: Supported channels in IEEE 802.11 format.\n @supported_oper_classes: Supported oper classes in IEEE 802.11 format.\n @sta_flags2: Unused.\n @ht_capability: HT capabilities of station.\n @vht_capability: VHT capabilities of station.\n @mac_addr: Station mac address.\n @opmode_notif: Information if operating mode field is used.\n @wme_uapsd_queues: Bitmap of queues configured for uapsd. Same format\n\tas the AC bitmap in the QoS info field.\n @wme_max_sp: Max Service Period. same format as the MAX_SP in the\n\tQoS info field (but already shifted down).\n\n This structure represents the information needed to update a station entry\n in the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_chg_sta_info {
    pub listen_interval: ::core::ffi::c_int,
    pub sta_vlan: ::core::ffi::c_uint,
    pub aid: ::core::ffi::c_ushort,
    pub peer_aid: ::core::ffi::c_ushort,
    pub sta_capability: ::core::ffi::c_ushort,
    pub spare: ::core::ffi::c_ushort,
    pub supp_rates: supp_rates,
    pub ext_capability: ext_capability,
    pub supported_channels: supported_channels,
    pub supported_oper_classes: supported_oper_classes,
    pub sta_flags2: sta_flag_update,
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub opmode_notif: ::core::ffi::c_uchar,
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[doc = " struct umac_cmd_chg_sta - Update station entry.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Information about station entry to be updated.\n\n This structure represents the command to update the parameters of a\n station entry."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_chg_sta {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_chg_sta_info,
}
#[doc = " struct umac_add_sta_info - Information about a station entry to be added.\n @listen_interval: Listen interval as defined by IEEE 802.11 7.3.1.6.\n @sta_vlan: VLAN interface station should belong to.\n @aid: AID or zero for no change.\n @peer_aid: Unused.\n @sta_capability: Station capability.\n @spare: Unused.\n @supp_rates: Supported rates in IEEE 802.11 format.\n @ext_capability: Extended capabilities of the station.\n @supported_channels: Supported channels in IEEE 802.11 format.\n @supported_oper_classes: Supported oper classes in IEEE 802.11 format.\n @sta_flags2: Unused.\n @ht_capability: HT capabilities of station.\n @vht_capability: VHT capabilities of station.\n @mac_addr: Station mac address.\n @opmode_notif: Information if operating mode field is used\n @wme_uapsd_queues: Bitmap of queues configured for uapsd. same format\n\tas the AC bitmap in the QoS info field.\n @wme_max_sp: Max Service Period. same format as the MAX_SP in the\n\tQoS info field (but already shifted down).\n\n This structure represents the information about a new station entry to be\n added to the RPU."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_add_sta_info {
    pub listen_interval: ::core::ffi::c_int,
    pub sta_vlan: ::core::ffi::c_uint,
    pub aid: ::core::ffi::c_ushort,
    pub peer_aid: ::core::ffi::c_ushort,
    pub sta_capability: ::core::ffi::c_ushort,
    pub spare: ::core::ffi::c_ushort,
    pub supp_rates: supp_rates,
    pub ext_capability: ext_capability,
    pub supported_channels: supported_channels,
    pub supported_oper_classes: supported_oper_classes,
    pub sta_flags2: sta_flag_update,
    pub ht_capability: [::core::ffi::c_uchar; 256usize],
    pub vht_capability: [::core::ffi::c_uchar; 256usize],
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub opmode_notif: ::core::ffi::c_uchar,
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    pub wme_max_sp: ::core::ffi::c_uchar,
}
#[doc = " struct umac_cmd_add_sta - Add station entry\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n\n This structure represents the commands to add a new station entry."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_add_sta {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_add_sta_info,
}
#[doc = " struct umac_start_ap_info - Attributes needed to start SoftAP operation.\n @beacon_interval: Beacon frame interval.\n @dtim_period: DTIM count.\n @hidden_ssid: Send beacons with wildcard sssid.\n @auth_type: Authentication type, see auth_type.\n @smps_mode: Unused.\n @flags: Beacon info flags.\n @beacon_data: Beacon frame, See &struct beacon_data.\n @ssid: SSID string, See &struct ssid.\n @connect_common_info: Connect params, See &struct connect_common_info.\n @freq_params: Channel info, See &struct freq_params.\n @inactivity_timeout: Time to stop ap after inactivity period.\n @p2p_go_ctwindow: P2P GO Client Traffic Window.\n @p2p_opp_ps: Opportunistic power save allows P2P Group Owner to save power\n\twhen all its associated clients are sleeping.\n\n This structure represents the attributes that need to be passed to the RPU\n when starting a SoftAP."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_start_ap_info {
    pub beacon_interval: ::core::ffi::c_ushort,
    pub dtim_period: ::core::ffi::c_uchar,
    pub hidden_ssid: ::core::ffi::c_int,
    pub auth_type: ::core::ffi::c_int,
    pub smps_mode: ::core::ffi::c_int,
    pub flags: ::core::ffi::c_uint,
    pub beacon_data: beacon_data,
    pub ssid: ssid,
    pub connect_common_info: connect_common_info,
    pub freq_params: freq_params,
    pub inactivity_timeout: ::core::ffi::c_ushort,
    pub p2p_go_ctwindow: ::core::ffi::c_uchar,
    pub p2p_opp_ps: ::core::ffi::c_uchar,
}
#[doc = " struct umac_cmd_start_ap - Start SoftAP\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Attributes that need to be passed to the RPU when starting a SoftAP.\n\t*See &struct umac_start_ap_info)\n\n The struct umac_cmd_start_ap is same for the following message types\n %UMAC_CMD_NEW_BEACON\n %UMAC_CMD_START_AP\n (Refer &enum umac_commands)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_start_ap {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_start_ap_info,
}
#[doc = " struct umac_cmd_stop_ap - Stop SoftAP\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to stop the operation of a Soft AP."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_stop_ap {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_set_beacon_info - Attributes needed to set Beacon & Probe Rsp.\n @beacon_data: Beacon frame, See &struct beacon_data.\n\n This structure represents the attributes that need to be passed to the RPU\n when Beacon & Probe Rsp data settings."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_set_beacon_info {
    pub beacon_data: beacon_data,
}
#[doc = " struct umac_cmd_set_beacon - Set beacon data\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: Attributes that need to be passed to the RPU when Beacon &\n\tProbe response data to set.\n\tSee &struct umac_set_beacon_info)\n\n %UMAC_CMD_SET_BEACON\n (Refer &enum umac_commands)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_beacon {
    pub umac_hdr: umac_hdr,
    pub info: umac_set_beacon_info,
}
#[doc = " struct umac_chg_vif_attr_info - Interface attributes to be changed.\n @iftype: Interface type, see &enum iftype.\n @user_4addr: Unused.\n\n This structure represents the information to be passed to the RPU when\n changing the attributes of a virtual interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_chg_vif_attr_info {
    pub iftype: ::core::ffi::c_int,
    pub use_4addr: ::core::ffi::c_int,
}
#[doc = " struct umac_cmd_chg_vif_attr - Change virtual interface attributes.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Interface attributes to be changed.\n\n This structure represents the command to change interface attributes."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_chg_vif_attr {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_chg_vif_attr_info,
}
#[doc = " struct umac_chg_vif_state_info- Interface state information.\n @state: Interface state (1 = UP / 0 = DOWN).\n @ifacename: Interface name.\n\n This structure represents the information to be passed the RPU when changing\n the state (up/down) of a virtual interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_chg_vif_state_info {
    pub state: ::core::ffi::c_int,
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[doc = " struct umac_cmd_chg_vif_state- Change the interface state\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: Interface state information.\n\n This structure represents the command to change interface state."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_chg_vif_state {
    pub umac_hdr: umac_hdr,
    pub info: umac_chg_vif_state_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_vif_state {
    pub umac_hdr: umac_hdr,
    pub status: ::core::ffi::c_int,
}
#[doc = " struct umac_cmd_start_p2p_dev - Start P2P mode on an interface\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to start P2P mode on an interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_start_p2p_dev {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_cmd_stop_p2p_dev - stop p2p mode\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to stop P2P mode on an interface."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_stop_p2p_dev {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_mgmt_tx_info - Information about a management frame to be\n\ttransmitted.\n @flags: OFFCHANNEL_TX_OK, NO_CCK_RATE, DONT_WAIT_FOR_ACK.\n @dur: Duration field value.\n @frame: Management frame to transmit.\n @frequency: Channel.\n @freq_params: Frequency configuration, See &struct freq_params.\n @host_cookie: Identifier to be used for processing done event,\n\tsee %UMAC_EVENT_FRAME_TX_STATUS.\n\n This structure represents the information about a management frame to be\n transmitted."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_mgmt_tx_info {
    pub flags: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_uint,
    pub dur: ::core::ffi::c_uint,
    pub frame: frame,
    pub freq_params: freq_params,
    pub host_cookie: ::core::ffi::c_ulonglong,
}
#[doc = " struct umac_cmd_mgmt_tx - Tranmit a management frame.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @info: Information about the management frame to be transmitted.\n\n This structure represents the command to transmit a management frame."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_mgmt_tx {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: umac_mgmt_tx_info,
}
#[doc = " struct umac_set_power_save_info - Information about power save\n\tsettings.\n @ps_state: power save is disabled or enabled, see enum ps_state.\n\n This structure represents the information about power save state"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_set_power_save_info {
    pub ps_state: ::core::ffi::c_int,
}
#[doc = " struct umac_cmd_set_power_save - Set power save enable or disbale.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: Power save parameters settings.\n\n This structure represents the command to enable or disable the power\n save functionality."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_power_save {
    pub umac_hdr: umac_hdr,
    pub info: umac_set_power_save_info,
}
#[doc = " struct umac_cmd_set_power_save_timeout - Set power save timeout.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @timeout: Timeout value in milli seconds.\n     if timeout < 0 RPU will set timeout to 100ms.\n\n This structure represents the command to configure power save timeout value."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_power_save_timeout {
    pub umac_hdr: umac_hdr,
    pub timeout: ::core::ffi::c_int,
}
#[doc = " struct umac_qos_map_info - qos map info.\n @qos_map_info_len: length of qos_map info field.\n @qos_map_info: contains qos_map info as received from stack.\n\n This structure represents the information of qos_map."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_qos_map_info {
    pub qos_map_info_len: ::core::ffi::c_uint,
    pub qos_map_info: [::core::ffi::c_uchar; 256usize],
}
#[doc = " struct umac_cmd_set_qos_map - Set qos map info.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: qos map info.\n\n This structure represents the command to pass qos_map info."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_qos_map {
    pub umac_hdr: umac_hdr,
    pub info: umac_qos_map_info,
}
#[doc = " struct umac_set_wowlan_info - Information about wowlan\n\ttrigger settings.\n @flags: Wakeup trigger conditions. SET_WOWLAN_FLAG_TRIG_ANY,\n SET_WOWLAN_FLAG_TRIG_DISCONNECT and etc.\n\n This structure represents the information about wowlan settings."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_set_wowlan_info {
    pub flags: ::core::ffi::c_ushort,
}
#[doc = " struct umac_cmd_set_wowlan - Setting Wake on WLAN configurations.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: WoWLAN wakeup trigger information.\n\n This structure represents the command to set the WoWLAN triger\n configs before going to sleep(Host)."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_wowlan {
    pub umac_hdr: umac_hdr,
    pub info: umac_set_wowlan_info,
}
#[doc = " struct umac_cmd_suspend - suspend the bus transactions.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to suspend the bus transactions."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_suspend {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_cmd_resume - resume the bus transactions.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to resumes the bus transactions."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_resume {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_cmd_get_tx_power - get tx power.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to get tx power."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_tx_power {
    pub umac_hdr: umac_hdr,
}
#[doc = " struct umac_cmd_get_channel - get channel info.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n\n This structure represents the command to get channel information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_channel {
    pub umac_hdr: umac_hdr,
}
#[repr(u32)]
#[doc = " enum twt_setup_cmd_type - TWT Setup command/Response type.\n @REQUEST_TWT:STA requests to join a TWT without specifying a target wake time.\n @SUGGEST_TWT:STA requests to join a TWT with specifying a target wake time and other\n\t\tparams, these values can change during negotiation.\n @DEMAND_TWT:requests to join a TWT with demanded a target wake time and other params.\n\t\tSTA rejects if AP not scheduling those params.\n @GROUPING_TWT:Response to the STA request(suggest/demand), these are may be different\n\t\tparams.\n @ACCEPT_TWT: AP accept the STA requested params.\n @ALTERNATE_TWT:AP may suggest the params, these may be different from STA requested.\n @DICTATE_TWT:AP may suggest the params, these may be different from STA requested.\n @REJECT_TWT: AP may reject the STA requested params.\n\n Types of TWT setup command/events."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum twt_setup_cmd_type {
    REQUEST_TWT = 0,
    SUGGEST_TWT = 1,
    DEMAND_TWT = 2,
    GROUPING_TWT = 3,
    ACCEPT_TWT = 4,
    ALTERNATE_TWT = 5,
    DICTATE_TWT = 6,
    REJECT_TWT = 7,
}
#[doc = " struct umac_config_twt_info - TWT params info.\n @twt_flow_id: TWT flow Id.\n @neg_type:TWT_NEGOTIATION_TYPE_INDIVIDUAL/TWT_NEGOTIATION_TYPE_BROADAST\n @setup_cmd: see enum twt_setup_cmd_type\n @ap_trigger_frame: indicating AP to initiate a trigger frame(ps_poll/Null) before data transfer\n @is_implicit:1->implicit(same negotiated values to be used), 0->AP sends new calculated TWT\n\tvalues for every service period.\n @twt_flow_type: Whether STA has to send the PS-Poll/Null frame\n\t\tindicating that it's in wake period(TWT_FLOW_TYPE_ANNOUNCED)\n @twt_target_wake_interval_exponent: wake interval exponent value\n @twt_target_wake_interval_mantissa: wake interval mantissa value\n @target_wake_time: start of the waketime value after successful TWT negotiation\n @nominal_min_twt_wake_duration: min TWT wake duration\n @dialog_token: dialog_token of twt frame.\n @twt_resp_status: 0->not received 1->received.\n This structure represents the command provides TWT information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_config_twt_info {
    pub twt_flow_id: ::core::ffi::c_uchar,
    pub neg_type: ::core::ffi::c_uchar,
    pub setup_cmd: ::core::ffi::c_int,
    pub ap_trigger_frame: ::core::ffi::c_uchar,
    pub is_implicit: ::core::ffi::c_uchar,
    pub twt_flow_type: ::core::ffi::c_uchar,
    pub twt_target_wake_interval_exponent: ::core::ffi::c_uchar,
    pub twt_target_wake_interval_mantissa: ::core::ffi::c_ushort,
    pub target_wake_time: ::core::ffi::c_ulonglong,
    pub nominal_min_twt_wake_duration: ::core::ffi::c_uint,
    pub dialog_token: ::core::ffi::c_uchar,
    pub twt_resp_status: ::core::ffi::c_uchar,
}
#[doc = " struct umac_cmd_config_twt - configuring TWT params.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: refer to struct umac_config_twt_info.\n This structure represents the command provides TWT information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_config_twt {
    pub umac_hdr: umac_hdr,
    pub info: umac_config_twt_info,
}
#[doc = " struct umac_teardown_twt_info - delete TWT params info.\n @twt_flow_id: TWT flow Id.\n @reason_code: reason for teardown.\n This structure represents the command provides TWT delete information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_teardown_twt_info {
    pub twt_flow_id: ::core::ffi::c_uchar,
    pub reason_code: ::core::ffi::c_uchar,
}
#[doc = " struct umac_cmd_del_twt - delete TWT establishment.\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: refer to struct umac_teardown_twt_info.\n This structure represents the command provides TWT delete establishment."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_teardown_twt {
    pub umac_hdr: umac_hdr,
    pub info: umac_teardown_twt_info,
}
#[doc = " struct twt_sleep_info- TWT sleep information\n @type: value for blocking/unblocking TX\n @info: refer to struct twt_sleep_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct twt_sleep_info {
    pub type_: ::core::ffi::c_uint,
}
#[doc = " struct umac_event_twt_sleep- TWT sleep information\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: refer to struct twt_sleep_info"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_twt_sleep {
    pub umac_hdr: umac_hdr,
    pub info: twt_sleep_info,
}
#[doc = " struct umac_uapsd_info - uaspd queues info\n @uapsd_queue: UAPSD-Q value\n This structure represents the information about UAPSD-Q."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_uapsd_info {
    pub uapsd_queue: ::core::ffi::c_uint,
}
#[doc = " struct umac_cmd_config_uapsd - Config UAPSD-Q..\n @umac_hdr: UMAC command header. Refer &struct umac_hdr.\n @info: Refer &struct umac_uapsd_info\n This structure represents the command to configure UAPSD-Q value."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_config_uapsd {
    pub umac_hdr: umac_hdr,
    pub info: umac_uapsd_info,
}
#[doc = " struct umac_event_trigger_scan - Scan complete event\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n\n This structure represents the event to indicate a scan complete and includes\n the scan complete information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_trigger_scan {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub scan_flags: ::core::ffi::c_uint,
    pub num_scan_ssid: ::core::ffi::c_uchar,
    pub num_scan_frequencies: ::core::ffi::c_uchar,
    pub scan_frequencies: [::core::ffi::c_ushort; 64usize],
    pub scan_ssid: [ssid; 2usize],
    pub ie: ie,
}
#[doc = " struct umac_event_new_scan_results - Scan result\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid.\n @generation: Used to indicate consistent snapshots for\n\tdumps. This number increases whenever the object list being\n\tdumped changes, and as such userspace can verify that it has\n\tobtained a complete and consistent snapshot by verifying that\n\tall dump messages contain the same generation number. If it\n\tchanged then the list changed and the dump should be repeated\n\tcompletely from scratch.\n @mac_addr: BSSID of the BSS (6 octets).\n @ies_tsf: TSF of the received probe response/beacon (u64)\n\t(if @BSS_PRESP_DATA is present then this is known to be\n\tfrom a probe response, otherwise it may be from the same beacon\n\tthat the BSS_BEACON_TSF will be from).\n @ies: Binary attribute containing the\n\traw information elements from the probe response/beacon (bin);\n\tif the %BSS_BEACON_IES attribute is present and the data is\n\tdifferent then the IEs here are from a Probe Response frame; otherwise\n\tthey are from a Beacon frame.\n\tHowever, if the driver does not indicate the source of the IEs, these\n\tIEs may be from either frame subtype.\n\tIf present, the @BSS_PRESP_DATA attribute indicates that the\n\tdata here is known to be from a probe response, without any heuristics.\n @beacon_ies_tsf: TSF of the last received beacon\n\t(not present if no beacon frame has been received yet).\n @beacon_ies: Binary attribute containing the raw information\n\telements from a Beacon frame (bin); not present if no Beacon frame has\n\tyet been received.\n @beacon_interval: Beacon interval of the (I)BSS.\n @capability: Capability field (CPU order).\n @frequency: Frequency in MHz.\n @chan_width: Channel width of the control channel.\n @seen_ms_ago: Age of this BSS entry in ms.\n @signal: If MBMsignal strength of probe response/beacon\n\tin mBm (100 * dBm) (s32) or signal strength of the probe\n\tresponse/beacon in unspecified units, scaled to 0..100\n @status: Status, if this BSS is \"used\".\n\n This structure is returned as a response for %UMAC_CMD_GET_SCAN_RESULTS. It\n contains a scan result entry."]
#[repr(C, packed)]
pub struct umac_event_new_scan_results {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub generation: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_uint,
    pub chan_width: ::core::ffi::c_uint,
    pub seen_ms_ago: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_uint,
    pub status: ::core::ffi::c_int,
    pub ies_tsf: ::core::ffi::c_ulonglong,
    pub beacon_ies_tsf: ::core::ffi::c_ulonglong,
    pub beacon_interval: ::core::ffi::c_ushort,
    pub capability: ::core::ffi::c_ushort,
    pub signal: signal,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub ies_len: ::core::ffi::c_uint,
    pub beacon_ies_len: ::core::ffi::c_uint,
    pub ies: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct umac_display_results {
    pub ssid: ssid,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub nwk_band: ::core::ffi::c_int,
    pub nwk_channel: ::core::ffi::c_uint,
    pub protocol_flags: ::core::ffi::c_uchar,
    pub security_type: ::core::ffi::c_int,
    pub beacon_interval: ::core::ffi::c_ushort,
    pub capability: ::core::ffi::c_ushort,
    pub signal: signal,
    pub twt_support: ::core::ffi::c_uchar,
    pub mfp_flag: ::core::ffi::c_uchar,
    pub reserved3: ::core::ffi::c_uchar,
    pub reserved4: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct umac_event_new_scan_display_results {
    pub umac_hdr: umac_hdr,
    pub event_bss_count: ::core::ffi::c_uchar,
    pub display_results: [umac_display_results; 8usize],
}
#[doc = " struct umac_event_mlme - MLME event\n\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate which of the following parameters are valid\n @frame: Frame data (binary attribute), including frame header\n\tand body, but not FCS; used, e.g., with UMAC_CMD_AUTHENTICATE and\n\t%UMAC_CMD_ASSOCIATE events.\n @mac_addr: BSSID of the BSS (6 octets)\n @frequency: Frequency of the selected channel in MHz\n @cookie: Generic 64-bit cookie to identify objects.\n @rx_signal_dbm: Signal strength in dBm (as a 32-bit int);\n\tthis attribute is (depending on the driver capabilities) added to\n\treceived frames indicated with %CMD_FRAME.\n @wme_uapsd_queues: Bitmap of uapsd queues.\n @flags: Indicate whether the frame was acked or timed out.\n\n This structure represents different STA MLME events for e.g. Authentication\n Response received, Association Response received etc.\n"]
#[repr(C, packed)]
pub struct umac_event_mlme {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_uint,
    pub rx_signal_dbm: ::core::ffi::c_uint,
    pub flags: ::core::ffi::c_uint,
    pub cookie: ::core::ffi::c_ulonglong,
    pub frame: frame,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub wme_uapsd_queues: ::core::ffi::c_uchar,
    pub req_ie_len: ::core::ffi::c_uint,
    pub req_ie: __IncompleteArrayField<::core::ffi::c_uchar>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_connect {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub status_code: ::core::ffi::c_ushort,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub req_ie: ::core::ffi::c_uchar,
    pub resp_ie: ::core::ffi::c_uchar,
    pub connect_ie: ie,
}
#[doc = " struct umac_event_new_station - Station add event.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate if assoc_req ies is valid.\n @is_sta_legacy: Set to 1 if STA is Legacy(a/b/g)\n @wme: set to 1: STA supports QoS/WME\n @mac_addr: Station mac address.\n @generation: generation number\n @sta_info: Station information.\n @assoc_req_ies: Ies passed by station doing assoc request.\n\n This structure represents an event which is generated when a station is\n added or deleted."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_new_station {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub wme: ::core::ffi::c_uchar,
    pub is_sta_legacy: ::core::ffi::c_uchar,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
    pub generation: ::core::ffi::c_uint,
    pub sta_info: sta_info,
    pub assoc_req_ies: ie,
}
#[doc = " struct\tumac_event_cookie_rsp - Cookie for management frame.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @valid_fields: Indicate if assoc_req ies is valid.\n @host_cookie: Identifier passed during %UMAC_CMD_FRAME.\n @cookie: Cookie used to indicate TX done in %UMAC_EVENT_FRAME_TX_STATUS\n\n We receive an RPU cookie that is associated with the host cookie\n passed during UMAC_CMD_FRAME"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_cookie_rsp {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub host_cookie: ::core::ffi::c_ulonglong,
    pub cookie: ::core::ffi::c_ulonglong,
    pub mac_addr: [::core::ffi::c_uchar; 6usize],
}
#[doc = " struct\tumac_event_get_txpwr - Tx power.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @txpwr_level: Tx power level\n\n Tx power information in dbm"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_get_tx_power {
    pub umac_hdr: umac_hdr,
    pub txpwr_level: ::core::ffi::c_int,
}
#[doc = " struct\tumac_event_set_interface - set interface status.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @return_value: return value\n\n UMAC_CMD_SET_INTERFACE status"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_set_interface {
    pub umac_hdr: umac_hdr,
    pub return_value: ::core::ffi::c_int,
}
#[repr(u32)]
#[doc = " enum channel_flags - channel flags\n\n Channel flags set by the regulatory control code.\n\n @CHAN_DISABLED: This channel is disabled.\n @CHAN_NO_IR: do not initiate radiation, this includes\n sending probe requests or beaconing.\n @CHAN_RADAR: Radar detection is required on this channel.\n @CHAN_NO_HT40PLUS: extension channel above this channel\n\tis not permitted.\n @CHAN_NO_HT40MINUS: extension channel below this channel\n\tis not permitted.\n @CHAN_NO_OFDM: OFDM is not allowed on this channel.\n @CHAN_NO_80MHZ: If the driver supports 80 MHz on the band,\n\tthis flag indicates that an 80 MHz channel cannot use this\n\tchannel as the control or any of the secondary channels.\n\tThis may be due to the driver or due to regulatory bandwidth\n\trestrictions.\n @CHAN_NO_160MHZ: If the driver supports 160 MHz on the band,\n\tthis flag indicates that an 160 MHz channel cannot use this\n\tchannel as the control or any of the secondary channels.\n\tThis may be due to the driver or due to regulatory bandwidth\n\trestrictions.\n @CHAN_INDOOR_ONLY: see %NL80211_FREQUENCY_ATTR_INDOOR_ONLY\n @CHAN_GO_CONCURRENT: see %NL80211_FREQUENCY_ATTR_GO_CONCURRENT\n @CHAN_NO_20MHZ: 20 MHz bandwidth is not permitted\n\ton this channel.\n @CHAN_NO_10MHZ: 10 MHz bandwidth is not permitted\n\ton this channel.\n"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum channel_flags {
    CHAN_DISABLED = 1,
    CHAN_NO_IR = 2,
    CHAN_RADAR = 8,
    CHAN_NO_HT40PLUS = 16,
    CHAN_NO_HT40MINUS = 32,
    CHAN_NO_OFDM = 64,
    CHAN_NO_80MHZ = 128,
    CHAN_NO_160MHZ = 256,
    CHAN_INDOOR_ONLY = 512,
    CHAN_GO_CONCURRENT = 1024,
    CHAN_NO_20MHZ = 2048,
    CHAN_NO_10MHZ = 4096,
}
#[doc = " struct chan_def - channel definition\n @chan: the (control) channel\n @width: channel width\n @center_frequency1: center frequency of first segment\n @center_frequency2: center frequency of second segment\n (only with 80+80 MHz)"]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct chan_definition {
    pub chan: channel,
    pub width: ::core::ffi::c_int,
    pub center_frequency1: ::core::ffi::c_uint,
    pub center_frequency2: ::core::ffi::c_uint,
}
#[doc = " struct\tumac_event_get_channel - Get channel info.\n @umac_hdr: UMAC event header. Refer &struct umac_hdr.\n @chan_def: Channel definition.\n\n The structure gives Channel information."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_get_channel {
    pub umac_hdr: umac_hdr,
    pub chan_def: chan_definition,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_ibss_join {
    pub umac_hdr: umac_hdr,
    pub ssid: ssid,
    pub freq_params: freq_params,
    pub bssid: [::core::ffi::c_uchar; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_leave_ibss {
    pub umac_hdr: umac_hdr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_win_sta_connect {
    pub umac_hdr: umac_hdr,
    pub center_frequency: ::core::ffi::c_uint,
    pub auth_type: ::core::ffi::c_int,
    pub wpa_ie: ie,
    pub ssid: ssid,
    pub bssid: [::core::ffi::c_uchar; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_start_p2p {
    pub umac_hdr: umac_hdr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_get_ifindex {
    pub umac_hdr: umac_hdr,
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_conn_info {
    pub umac_hdr: umac_hdr,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum link_mode {
    MODE_11B = 1,
    MODE_11A = 2,
    MODE_11G = 3,
    MODE_11N = 4,
    MODE_11AC = 5,
    MODE_11AX = 6,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_conn_info {
    pub umac_hdr: umac_hdr,
    pub beacon_interval: ::core::ffi::c_ushort,
    pub dtim_interval: ::core::ffi::c_uchar,
    pub associated: ::core::ffi::c_uchar,
    pub twt_capable: ::core::ffi::c_uchar,
    pub linkmode: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_get_power_save_info {
    pub umac_hdr: umac_hdr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_set_listen_interval {
    pub umac_hdr: umac_hdr,
    pub listen_interval: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_config_extended_ps {
    pub umac_hdr: umac_hdr,
    pub enable_extended_ps: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
pub struct umac_event_power_save_info {
    pub umac_hdr: umac_hdr,
    pub ps_mode: ::core::ffi::c_uchar,
    pub enabled: ::core::ffi::c_uchar,
    pub extended_ps: ::core::ffi::c_uchar,
    pub twt_responder: ::core::ffi::c_uchar,
    pub ps_timeout: ::core::ffi::c_int,
    pub listen_interval: ::core::ffi::c_ushort,
    pub num_twt_flows: ::core::ffi::c_uchar,
    pub twt_flow_info: __IncompleteArrayField<umac_config_twt_info>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct tx_rates {
    pub legacy_len: ::core::ffi::c_uint,
    pub ht_mcs_len: ::core::ffi::c_uint,
    pub vht_mcs_len: ::core::ffi::c_uint,
    pub legacy: [::core::ffi::c_uchar; 8usize],
    pub ht_mcs: [::core::ffi::c_uchar; 10usize],
    pub vht_mcs: [::core::ffi::c_ushort; 8usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct set_tx_bitrate_mask {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub control: [tx_rates; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct remain_on_channel_info {
    pub dur: ::core::ffi::c_uint,
    pub freq_params: freq_params,
    pub host_cookie: ::core::ffi::c_ulonglong,
    pub cookie: ::core::ffi::c_ulonglong,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_remain_on_channel {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub info: remain_on_channel_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_cmd_cancel_remain_on_channel {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub cookie: ::core::ffi::c_ulonglong,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_remain_on_channel {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub frequency: ::core::ffi::c_uint,
    pub dur: ::core::ffi::c_uint,
    pub ch_type: ::core::ffi::c_uint,
    pub cookie: ::core::ffi::c_ulonglong,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_get_interface {
    pub umac_hdr: umac_hdr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct interface_info {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub iftype: ::core::ffi::c_int,
    pub ifacename: [::core::ffi::c_schar; 16usize],
    pub eth_addr: [::core::ffi::c_uchar; 6usize],
    pub chan_def: chan_definition,
    pub ssid: ssid,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_mcs_info {
    pub rx_highest: ::core::ffi::c_ushort,
    pub rx_mask: [::core::ffi::c_uchar; 10usize],
    pub tx_params: ::core::ffi::c_uchar,
    pub reserved: [::core::ffi::c_uchar; 3usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_sta_ht_cap {
    pub ht_supported: ::core::ffi::c_int,
    pub cap: ::core::ffi::c_ushort,
    pub mcs: event_mcs_info,
    pub ampdu_factor: ::core::ffi::c_uchar,
    pub ampdu_density: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_channel {
    pub flags: ::core::ffi::c_ushort,
    pub max_power: ::core::ffi::c_int,
    pub time: ::core::ffi::c_uint,
    pub dfs_cac_msec: ::core::ffi::c_uint,
    pub ch_valid: ::core::ffi::c_schar,
    pub center_frequency: ::core::ffi::c_ushort,
    pub dfs_state: ::core::ffi::c_schar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_rate {
    pub flags: ::core::ffi::c_ushort,
    pub bitrate: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_vht_mcs_info {
    pub rx_mcs_map: ::core::ffi::c_ushort,
    pub rx_highest: ::core::ffi::c_ushort,
    pub tx_mcs_map: ::core::ffi::c_ushort,
    pub tx_highest: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_sta_vht_cap {
    pub vht_supported: ::core::ffi::c_schar,
    pub cap: ::core::ffi::c_uint,
    pub vht_mcs: event_vht_mcs_info,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_supported_band {
    pub n_channels: ::core::ffi::c_ushort,
    pub n_bitrates: ::core::ffi::c_ushort,
    pub channels: [event_channel; 29usize],
    pub bitrates: [event_rate; 13usize],
    pub ht_cap: event_sta_ht_cap,
    pub vht_cap: event_sta_vht_cap,
    pub band: ::core::ffi::c_schar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_iface_limit {
    pub max: ::core::ffi::c_ushort,
    pub types: ::core::ffi::c_ushort,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_iface_combination {
    pub num_different_channels: ::core::ffi::c_uint,
    pub beacon_int_infra_match: ::core::ffi::c_int,
    pub limits: [event_iface_limit; 2usize],
    pub max_interfaces: ::core::ffi::c_ushort,
    pub radar_detect_widths: ::core::ffi::c_uchar,
    pub n_limits: ::core::ffi::c_uchar,
    pub radar_detect_regions: ::core::ffi::c_uchar,
    pub comb_valid: ::core::ffi::c_uchar,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_get_wiphy {
    pub umac_hdr: umac_hdr,
    pub frag_threshold: ::core::ffi::c_uint,
    pub rts_threshold: ::core::ffi::c_uint,
    pub available_antennas_tx: ::core::ffi::c_uint,
    pub available_antennas_rx: ::core::ffi::c_uint,
    pub probe_resp_offload: ::core::ffi::c_uint,
    pub tx_ant: ::core::ffi::c_uint,
    pub rx_ant: ::core::ffi::c_uint,
    pub split_start2_flags: ::core::ffi::c_uint,
    pub max_remain_on_channel_duration: ::core::ffi::c_uint,
    pub ap_sme_capa: ::core::ffi::c_uint,
    pub features: ::core::ffi::c_uint,
    pub max_acl_mac_addresses: ::core::ffi::c_uint,
    pub max_ap_assoc_sta: ::core::ffi::c_uint,
    pub cipher_suites: [::core::ffi::c_uint; 30usize],
    pub get_wiphy_flags: ::core::ffi::c_uint,
    pub params_valid: ::core::ffi::c_uint,
    pub max_scan_ie_len: ::core::ffi::c_ushort,
    pub max_sched_scan_ie_len: ::core::ffi::c_ushort,
    pub interface_modes: ::core::ffi::c_ushort,
    pub iface_com: [event_iface_combination; 6usize],
    pub supp_commands: [::core::ffi::c_schar; 40usize],
    pub retry_short: ::core::ffi::c_uchar,
    pub retry_long: ::core::ffi::c_uchar,
    pub coverage_class: ::core::ffi::c_uchar,
    pub max_scan_ssids: ::core::ffi::c_uchar,
    pub max_sched_scan_ssids: ::core::ffi::c_uchar,
    pub max_match_sets: ::core::ffi::c_uchar,
    pub n_cipher_suites: ::core::ffi::c_uchar,
    pub max_num_pmkids: ::core::ffi::c_uchar,
    pub extended_capabilities_len: ::core::ffi::c_uchar,
    pub extended_capabilities: [::core::ffi::c_uchar; 10usize],
    pub extended_capabilities_mask: [::core::ffi::c_uchar; 10usize],
    pub ext_features: [::core::ffi::c_uchar; 8usize],
    pub ext_features_len: ::core::ffi::c_uchar,
    pub num_iface_com: ::core::ffi::c_schar,
    pub wiphy_name: [::core::ffi::c_schar; 32usize],
    pub sband: [event_supported_band; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_get_wiphy {
    pub umac_hdr: umac_hdr,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_get_ifhwaddr {
    pub umac_hdr: umac_hdr,
    pub ifacename: [::core::ffi::c_schar; 16usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_set_ifhwaddr {
    pub umac_hdr: umac_hdr,
    pub ifacename: [::core::ffi::c_schar; 16usize],
    pub hwaddr: [::core::ffi::c_uchar; 6usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct reg_rules {
    pub valid_fields: ::core::ffi::c_uint,
    pub rule_flags: ::core::ffi::c_uint,
    pub freq_range_start: ::core::ffi::c_uint,
    pub freq_range_end: ::core::ffi::c_uint,
    pub freq_range_max_bw: ::core::ffi::c_uint,
    pub pwr_max_eirp: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct reg {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub dfs_region: ::core::ffi::c_uint,
    pub num_reg_rules: ::core::ffi::c_uint,
    pub reg_rules: [reg_rules; 32usize],
    pub alpha2: [::core::ffi::c_uchar; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct cmd_req_set_reg {
    pub umac_hdr: umac_hdr,
    pub valid_fields: ::core::ffi::c_uint,
    pub user_reg_hint_type: ::core::ffi::c_uint,
    pub alpha2: [::core::ffi::c_uchar; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_send_beacon_hint {
    pub umac_hdr: umac_hdr,
    pub channel_before: event_channel,
    pub channel_after: event_channel,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct event_regulatory_change {
    pub umac_hdr: umac_hdr,
    pub flags: ::core::ffi::c_ushort,
    pub intr: ::core::ffi::c_int,
    pub regulatory_type: ::core::ffi::c_schar,
    pub alpha2: [::core::ffi::c_uchar; 2usize],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_cmd_status {
    pub umac_hdr: umac_hdr,
    pub cmd_id: ::core::ffi::c_uint,
    pub cmd_status: ::core::ffi::c_uint,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct umac_event_coalesce {
    pub umac_hdr: umac_hdr,
    pub sta_addr: [::core::ffi::c_uchar; 6usize],
    pub tid: ::core::ffi::c_ushort,
    pub coalesce: ::core::ffi::c_uchar,
}
